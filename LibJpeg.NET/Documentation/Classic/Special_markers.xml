<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Special markers</title>
    <breadcumbs>
      <link file="..\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>Some applications may need to insert or extract special data in the JPEG datastream. The JPEG standard provides marker types "COM" (comment) and "APP0" through "APP15" (application) to hold application-specific data. Unfortunately, the use of these markers is not specified by the standard. COM markers are fairly widely used to hold user-supplied text. The JFIF file format spec uses APP0 markers with specified initial strings to hold certain data. Adobe applications use APP14 markers beginning with the string "Adobe" for miscellaneous data. Other APPn markers are rarely seen, but might</text> <br /><text>contain almost anything.</text> <br /><br /><text>If you wish to store user-supplied text, we recommend you use COM markers and place readable 7-bit ASCII text in them. Newline conventions are not standardized - expect to find LF (Unix style), CR/LF (DOS style), or CR (Mac style). A robust COM reader should be able to cope with random binary garbage, including nulls, since some applications generate COM markers containing non-ASCII junk. (But yours should not be one of them.)</text> <br /><br /><text>For program-supplied data, use an APPn marker, and be sure to begin it with an identifying string so that you can tell whether the marker is actually yours. It's probably best to avoid using APP0 or APP14 for any private markers.</text> <br /><text>(NOTE: the upcoming SPIFF standard will use APP8 markers; we recommend you</text> <br /><text>not use APP8 markers for any private purposes, either.)</text> <br /><br /><text>Keep in mind that at most 65533 bytes can be put into one marker, but you can have as many markers as you like.</text> <br /><br /><text>By default, the IJG compression library will write a JFIF APP0 marker if the selected JPEG colorspace is grayscale or YCbCr, or an Adobe APP14 marker if the selected colorspace is RGB, CMYK, or YCCK. You can disable this, but we don't recommend it. The decompression library will recognize JFIF and Adobe markers and will set the JPEG colorspace properly when one is found.</text> <br /><br /><text>You can write special markers immediately following the datastream header by calling </text> <link file="../jpeg_compress_struct.jpeg_write_marker.xml"><text>jpeg_write_marker</text> </link><text>(). When you do this, the markers appear after the SOI and the JFIF APP0 and Adobe APP14 markers (if written), but before all else.</text> <br /><br /><text>If it's not convenient to store all the marker data in memory at once, you can instead call jpeg_write_m_header() followed by multiple calls to jpeg_write_m_byte(). If you do it this way, it's your responsibility to call jpeg_write_m_byte() exactly the number of times given in the length parameter to jpeg_write_m_header(). (This method lets you empty the output buffer partway through a marker, which might be important when</text> <br /><text>using a suspending data destination module. In any case, if you are using a suspending destination, you should flush its buffer after inserting any special markers. See "I/O suspension".)</text> <br /><br /><text>Or, if you prefer to synthesize the marker byte sequence yourself, you can just cram it straight into the data destination module.</text> <br /><br /><text>If you are writing JFIF 1.02 extension markers (thumbnail images), don't forget to set cinfo.JFIF_minor_version = 2 so that the encoder will write the correct JFIF version number in the JFIF header marker. The library's default is to write version 1.01, but that's wrong if you insert any 1.02 extension markers. (We could probably get away with just defaulting to 1.02, but there used to be broken decoders that would complain about unknown minor version numbers. To reduce compatibility risks it's safest not to write 1.02 unless you are actually using 1.02 extensions.)</text> <br /><br /><text>When reading, two methods of handling special markers are available:</text> <br /><text>1. You can ask the library to save the contents of COM and/or APPn markers into memory, and then examine them at your leisure afterwards.</text> <br /><text>2. You can supply your own routine to process COM and/or APPn markers on-the-fly as they are read.</text> <br /><text>The first method is simpler to use, especially if you are using a suspending data source; writing a marker processor that copes with input suspension is not easy (consider what happens if the marker is longer than your available input buffer). However, the second method conserves memory since the marker data need not be kept around after it's been processed.</text> <br /><br /><text>For either method, you'd normally set up marker handling after creating a decompression object and before calling jpeg_read_header(), because the markers of interest will typically be near the head of the file and so will be scanned by jpeg_read_header. Once you've established a marker handling method, it will be used for the life of that decompression object (potentially many datastreams), unless you change it. Marker handling is determined separately for COM markers and for each APPn marker code.</text> <br /><br /><text>To save the contents of special markers in memory, call jpeg_save_markers(cinfo, marker_code, length_limit) where marker_code is the marker type to save, JPEG_COM or JPEG_APP0+n.</text> <br /><text>(To arrange to save all the special marker types, you need to call this routine 17 times, for COM and APP0-APP15.) If the incoming marker is longer than length_limit data bytes, only length_limit bytes will be saved; this parameter allows you to avoid chewing up memory when you only need to see the first few bytes of a potentially large marker. If you want to save all the data, set length_limit to 0xFFFF; that is enough since marker lengths are only 16 bits. As a special case, setting length_limit to 0 prevents that marker type from being saved at all. (That is the default behavior, in fact.)</text> <br /><br /><text>After jpeg_read_header() completes, you can examine the special markers by following the cinfo-&gt;marker_list pointer chain. All the special markers in the file appear in this list, in order of their occurrence in the file (but omitting any markers of types you didn't ask for). Both the original data length and the saved data length are recorded for each list entry; the latter will not exceed length_limit for the particular marker type. Note that these lengths exclude the marker length word, whereas the stored representation within the JPEG file includes it. (Hence the maximum data length is really only 65533.)</text> <br /><br /><text>It is possible that additional special markers appear in the file beyond the SOS marker at which jpeg_read_header stops; if so, the marker list will be extended during reading of the rest of the file. This is not expected to be common, however. If you are short on memory you may want to reset the length limit to zero for all marker types after finishing jpeg_read_header, to ensure that the max_memory_to_use setting cannot be exceeded due to addition of later markers.</text> <br /><br /><text>The marker list remains stored until you call jpeg_finish_decompress or jpeg_abort, at which point the memory is freed and the list is set to empty. (jpeg_destroy also releases the storage, of course.)</text> <br /><br /><text>Note that the library is internally interested in APP0 and APP14 markers; if you try to set a small nonzero length limit on these types, the library will silently force the length up to the minimum it wants. (But you can set a zero length limit to prevent them from being saved at all.) Also, in a 16-bit environment, the maximum length limit may be constrained to less than 65533 by malloc() limitations. It is therefore best not to assume that the effective length limit is exactly what you set it to be.</text> <br /><br /><text>If you want to supply your own marker-reading routine, you do it by clling</text> <br /><text>jpeg_set_marker_processor(). A marker processor routine must have the signature</text> <br /><text>boolean jpeg_marker_parser_method (j_decompress_ptr cinfo)</text> <br /><text>Although the marker code is not explicitly passed, the routine can find it in cinfo-&gt;unread_marker. At the time of call, the marker proper has been read from the data source module. The processor routine is responsible for reading the marker length word and the remaining parameter bytes, if any. Return TRUE to indicate success. (FALSE should be returned only if you are using a suspending data source and it tells you to suspend.</text> <br /><text>If you override the default APP0 or APP14 processors, it is up to you to recognize JFIF and Adobe markers if you want colorspace recognition to occur properly. We recommend copying and extending the default processors if you want to do that. (A better idea is to save these marker types for later examination by calling jpeg_save_markers(); that method doesn't interfere with the library's own processing of these markers.)</text> <br /><br /><text>jpeg_set_marker_processor() and jpeg_save_markers() are mutually exclusive - if you call one it overrides any previous call to the other, for the particular marker type specified.</text> </descriptionarticle>
  </file>
</xml>