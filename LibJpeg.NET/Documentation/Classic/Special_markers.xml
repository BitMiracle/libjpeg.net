<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Special markers</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>Some applications may need to insert or extract special data in the JPEG</text> <br /><text>datastream. The JPEG standard provides marker types "COM" (comment) and</text> <br /><text>"APP0" through "APP15" (application) to hold application-specific data.</text> <br /><text>Unfortunately, the use of these markers is not specified by the standard.</text> <br /><text>COM markers are fairly widely used to hold user-supplied text. The JFIF file</text> <br /><text>format spec uses APP0 markers with specified initial strings to hold certain</text> <br /><text>data. Adobe applications use APP14 markers beginning with the string "Adobe"</text> <br /><text>for miscellaneous data. Other APPn markers are rarely seen, but might</text> <br /><text>contain almost anything.</text> <br /><br /><text>If you wish to store user-supplied text, we recommend you use COM markers</text> <br /><text>and place readable 7-bit ASCII text in them. Newline conventions are not</text> <br /><text>standardized --- expect to find LF (Unix style), CR/LF (DOS style), or CR</text> <br /><text>(Mac style). A robust COM reader should be able to cope with random binary</text> <br /><text>garbage, including nulls, since some applications generate COM markers</text> <br /><text>containing non-ASCII junk. (But yours should not be one of them.)</text> <br /><br /><text>For program-supplied data, use an APPn marker, and be sure to begin it with an</text> <br /><text>identifying string so that you can tell whether the marker is actually yours.</text> <br /><text>It's probably best to avoid using APP0 or APP14 for any private markers.</text> <br /><text>(NOTE: the upcoming SPIFF standard will use APP8 markers; we recommend you</text> <br /><text>not use APP8 markers for any private purposes, either.)</text> <br /><br /><text>Keep in mind that at most 65533 bytes can be put into one marker, but you</text> <br /><text>can have as many markers as you like.</text> <br /><br /><text>By default, the IJG compression library will write a JFIF APP0 marker if the</text> <br /><text>selected JPEG colorspace is grayscale or YCbCr, or an Adobe APP14 marker if</text> <br /><text>the selected colorspace is RGB, CMYK, or YCCK. You can disable this, but</text> <br /><text>we don't recommend it. The decompression library will recognize JFIF and</text> <br /><text>Adobe markers and will set the JPEG colorspace properly when one is found.</text> <br /><br /><br /><text>You can write special markers immediately following the datastream header by</text> <br /><text>calling jpeg_write_marker() after jpeg_start_compress() and before the first</text> <br /><text>call to jpeg_write_scanlines(). When you do this, the markers appear after</text> <br /><text>the SOI and the JFIF APP0 and Adobe APP14 markers (if written), but before</text> <br /><text>all else. Specify the marker type parameter as "JPEG_COM" for COM or</text> <br /><text>"JPEG_APP0 + n" for APPn. (Actually, jpeg_write_marker will let you write</text> <br /><text>any marker type, but we don't recommend writing any other kinds of marker.)</text> <br /><text>For example, to write a user comment string pointed to by comment_text:</text> <br /><text>jpeg_write_marker(cinfo, JPEG_COM, comment_text, strlen(comment_text));</text> <br /><br /><text>If it's not convenient to store all the marker data in memory at once,</text> <br /><text>you can instead call jpeg_write_m_header() followed by multiple calls to</text> <br /><text>jpeg_write_m_byte(). If you do it this way, it's your responsibility to</text> <br /><text>call jpeg_write_m_byte() exactly the number of times given in the length</text> <br /><text>parameter to jpeg_write_m_header(). (This method lets you empty the</text> <br /><text>output buffer partway through a marker, which might be important when</text> <br /><text>using a suspending data destination module. In any case, if you are using</text> <br /><text>a suspending destination, you should flush its buffer after inserting</text> <br /><text>any special markers. See "I/O suspension".)</text> <br /><br /><text>Or, if you prefer to synthesize the marker byte sequence yourself,</text> <br /><text>you can just cram it straight into the data destination module.</text> <br /><br /><text>If you are writing JFIF 1.02 extension markers (thumbnail images), don't</text> <br /><text>forget to set cinfo.JFIF_minor_version = 2 so that the encoder will write the</text> <br /><text>correct JFIF version number in the JFIF header marker. The library's default</text> <br /><text>is to write version 1.01, but that's wrong if you insert any 1.02 extension</text> <br /><text>markers. (We could probably get away with just defaulting to 1.02, but there</text> <br /><text>used to be broken decoders that would complain about unknown minor version</text> <br /><text>numbers. To reduce compatibility risks it's safest not to write 1.02 unless</text> <br /><text>you are actually using 1.02 extensions.)</text> <br /><br /><br /><text>When reading, two methods of handling special markers are available:</text> <br /><text>1. You can ask the library to save the contents of COM and/or APPn markers</text> <br /><text>into memory, and then examine them at your leisure afterwards.</text> <br /><text>2. You can supply your own routine to process COM and/or APPn markers</text> <br /><text>on-the-fly as they are read.</text> <br /><text>The first method is simpler to use, especially if you are using a suspending</text> <br /><text>data source; writing a marker processor that copes with input suspension is</text> <br /><text>not easy (consider what happens if the marker is longer than your available</text> <br /><text>input buffer). However, the second method conserves memory since the marker</text> <br /><text>data need not be kept around after it's been processed.</text> <br /><br /><text>For either method, you'd normally set up marker handling after creating a</text> <br /><text>decompression object and before calling jpeg_read_header(), because the</text> <br /><text>markers of interest will typically be near the head of the file and so will</text> <br /><text>be scanned by jpeg_read_header. Once you've established a marker handling</text> <br /><text>method, it will be used for the life of that decompression object</text> <br /><text>(potentially many datastreams), unless you change it. Marker handling is</text> <br /><text>determined separately for COM markers and for each APPn marker code.</text> <br /><br /><br /><text>To save the contents of special markers in memory, call</text> <br /><text>jpeg_save_markers(cinfo, marker_code, length_limit)</text> <br /><text>where marker_code is the marker type to save, JPEG_COM or JPEG_APP0+n.</text> <br /><text>(To arrange to save all the special marker types, you need to call this</text> <br /><text>routine 17 times, for COM and APP0-APP15.) If the incoming marker is longer</text> <br /><text>than length_limit data bytes, only length_limit bytes will be saved; this</text> <br /><text>parameter allows you to avoid chewing up memory when you only need to see the</text> <br /><text>first few bytes of a potentially large marker. If you want to save all the</text> <br /><text>data, set length_limit to 0xFFFF; that is enough since marker lengths are only</text> <br /><text>16 bits. As a special case, setting length_limit to 0 prevents that marker</text> <br /><text>type from being saved at all. (That is the default behavior, in fact.)</text> <br /><br /><br /><text>After jpeg_read_header() completes, you can examine the special markers by</text> <br /><text>following the cinfo-&gt;marker_list pointer chain. All the special markers in</text> <br /><text>the file appear in this list, in order of their occurrence in the file (but</text> <br /><text>omitting any markers of types you didn't ask for). Both the original data</text> <br /><text>length and the saved data length are recorded for each list entry; the latter</text> <br /><text>will not exceed length_limit for the particular marker type. Note that these</text> <br /><text>lengths exclude the marker length word, whereas the stored representation</text> <br /><text>within the JPEG file includes it. (Hence the maximum data length is really</text> <br /><text>only 65533.)</text> <br /><br /><text>It is possible that additional special markers appear in the file beyond the</text> <br /><text>SOS marker at which jpeg_read_header stops; if so, the marker list will be</text> <br /><text>extended during reading of the rest of the file. This is not expected to be</text> <br /><text>common, however. If you are short on memory you may want to reset the length</text> <br /><text>limit to zero for all marker types after finishing jpeg_read_header, to</text> <br /><text>ensure that the max_memory_to_use setting cannot be exceeded due to addition</text> <br /><text>of later markers.</text> <br /><br /><text>The marker list remains stored until you call jpeg_finish_decompress or</text> <br /><text>jpeg_abort, at which point the memory is freed and the list is set to empty.</text> <br /><text>(jpeg_destroy also releases the storage, of course.)</text> <br /><br /><text>Note that the library is internally interested in APP0 and APP14 markers;</text> <br /><text>if you try to set a small nonzero length limit on these types, the library</text> <br /><text>will silently force the length up to the minimum it wants. (But you can set</text> <br /><text>a zero length limit to prevent them from being saved at all.) Also, in a</text> <br /><text>16-bit environment, the maximum length limit may be constrained to less than</text> <br /><text>65533 by malloc() limitations. It is therefore best not to assume that the</text> <br /><text>effective length limit is exactly what you set it to be.</text> <br /><br /><br /><text>If you want to supply your own marker-reading routine, you do it by calling</text> <br /><text>jpeg_set_marker_processor(). A marker processor routine must have the</text> <br /><text>signature</text> <br /><text>boolean jpeg_marker_parser_method (j_decompress_ptr cinfo)</text> <br /><text>Although the marker code is not explicitly passed, the routine can find it</text> <br /><text>in cinfo-&gt;unread_marker. At the time of call, the marker proper has been</text> <br /><text>read from the data source module. The processor routine is responsible for</text> <br /><text>reading the marker length word and the remaining parameter bytes, if any.</text> <br /><text>Return TRUE to indicate success. (FALSE should be returned only if you are</text> <br /><text>using a suspending data source and it tells you to suspend. See the standard</text> <br /><text>marker processors in jdmarker.c for appropriate coding methods if you need to</text> <br /><text>use a suspending data source.)</text> <br /><br /><text>If you override the default APP0 or APP14 processors, it is up to you to</text> <br /><text>recognize JFIF and Adobe markers if you want colorspace recognition to occur</text> <br /><text>properly. We recommend copying and extending the default processors if you</text> <br /><text>want to do that. (A better idea is to save these marker types for later</text> <br /><text>examination by calling jpeg_save_markers(); that method doesn't interfere</text> <br /><text>with the library's own processing of these markers.)</text> <br /><br /><text>jpeg_set_marker_processor() and jpeg_save_markers() are mutually exclusive</text> <br /><text>--- if you call one it overrides any previous call to the other, for the</text> <br /><text>particular marker type specified.</text> </descriptionarticle>
  </file>
</xml>