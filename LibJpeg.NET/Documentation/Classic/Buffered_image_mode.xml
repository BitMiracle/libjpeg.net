<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Buffered-image mode</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>In buffered-image mode, the library stores the partially decoded image in a</text> <br /><text>coefficient buffer, from which it can be read out as many times as desired.</text> <br /><text>This mode is typically used for incremental display of progressive JPEG files,</text> <br /><text>but it can be used with any JPEG file. Each scan of a progressive JPEG file</text> <br /><text>adds more data (more detail) to the buffered image. The application can</text> <br /><text>display in lockstep with the source file (one display pass per input scan),</text> <br /><text>or it can allow input processing to outrun display processing. By making</text> <br /><text>input and display processing run independently, it is possible for the</text> <br /><text>application to adapt progressive display to a wide range of data transmission</text> <br /><text>rates.</text> <br /><br /><text>The basic control flow for buffered-image decoding is</text> <br /><br /><text>jpeg_create_decompress()</text> <br /><text>set data source</text> <br /><text>jpeg_read_header()</text> <br /><text>set overall decompression parameters</text> <br /><text>cinfo.buffered_image = TRUE; /* select buffered-image mode */</text> <br /><text>jpeg_start_decompress()</text> <br /><text>for (each output pass) {</text> <br /><text>adjust output decompression parameters if required</text> <br /><text>jpeg_start_output() /* start a new output pass */</text> <br /><text>for (all scanlines in image) {</text> <br /><text>jpeg_read_scanlines()</text> <br /><text>display scanlines</text> <br /><text>}</text> <br /><text>jpeg_finish_output() /* terminate output pass */</text> <br /><text>}</text> <br /><text>jpeg_finish_decompress()</text> <br /><text>jpeg_destroy_decompress()</text> <br /><br /><text>This differs from ordinary unbuffered decoding in that there is an additional</text> <br /><text>level of looping. The application can choose how many output passes to make</text> <br /><text>and how to display each pass.</text> <br /><br /><text>The simplest approach to displaying progressive images is to do one display</text> <br /><text>pass for each scan appearing in the input file. In this case the outer loop</text> <br /><text>condition is typically</text> <br /><text>while (! jpeg_input_complete(&amp;cinfo))</text> <br /><text>and the start-output call should read</text> <br /><text>jpeg_start_output(&amp;cinfo, cinfo.input_scan_number);</text> <br /><text>The second parameter to jpeg_start_output() indicates which scan of the input</text> <br /><text>file is to be displayed; the scans are numbered starting at 1 for this</text> <br /><text>purpose. (You can use a loop counter starting at 1 if you like, but using</text> <br /><text>the library's input scan counter is easier.) The library automatically reads</text> <br /><text>data as necessary to complete each requested scan, and jpeg_finish_output()</text> <br /><text>advances to the next scan or end-of-image marker (hence input_scan_number</text> <br /><text>will be incremented by the time control arrives back at jpeg_start_output()).</text> <br /><text>With this technique, data is read from the input file only as needed, and</text> <br /><text>input and output processing run in lockstep.</text> <br /><br /><text>After reading the final scan and reaching the end of the input file, the</text> <br /><text>buffered image remains available; it can be read additional times by</text> <br /><text>repeating the jpeg_start_output()/jpeg_read_scanlines()/jpeg_finish_output()</text> <br /><text>sequence. For example, a useful technique is to use fast one-pass color</text> <br /><text>quantization for display passes made while the image is arriving, followed by</text> <br /><text>a final display pass using two-pass quantization for highest quality. This</text> <br /><text>is done by changing the library parameters before the final output pass.</text> <br /><text>Changing parameters between passes is discussed in detail below.</text> <br /><br /><text>In general the last scan of a progressive file cannot be recognized as such</text> <br /><text>until after it is read, so a post-input display pass is the best approach if</text> <br /><text>you want special processing in the final pass.</text> <br /><br /><text>When done with the image, be sure to call jpeg_finish_decompress() to release</text> <br /><text>the buffered image (or just use jpeg_destroy_decompress()).</text> <br /><br /><text>If input data arrives faster than it can be displayed, the application can</text> <br /><text>cause the library to decode input data in advance of what's needed to produce</text> <br /><text>output. This is done by calling the routine jpeg_consume_input().</text> <br /><text>The return value is one of the following:</text> <br /><text>JPEG_REACHED_SOS: reached an SOS marker (the start of a new scan)</text> <br /><text>JPEG_REACHED_EOI: reached the EOI marker (end of image)</text> <br /><text>JPEG_ROW_COMPLETED: completed reading one MCU row of compressed data</text> <br /><text>JPEG_SCAN_COMPLETED: completed reading last MCU row of current scan</text> <br /><text>JPEG_SUSPENDED: suspended before completing any of the above</text> <br /><text>(JPEG_SUSPENDED can occur only if a suspending data source is used.) This</text> <br /><text>routine can be called at any time after initializing the JPEG object. It</text> <br /><text>reads some additional data and returns when one of the indicated significant</text> <br /><text>events occurs. (If called after the EOI marker is reached, it will</text> <br /><text>immediately return JPEG_REACHED_EOI without attempting to read more data.)</text> <br /><br /><text>The library's output processing will automatically call jpeg_consume_input()</text> <br /><text>whenever the output processing overtakes the input; thus, simple lockstep</text> <br /><text>display requires no direct calls to jpeg_consume_input(). But by adding</text> <br /><text>calls to jpeg_consume_input(), you can absorb data in advance of what is</text> <br /><text>being displayed. This has two benefits:</text> <br /><text>* You can limit buildup of unprocessed data in your input buffer.</text> <br /><text>* You can eliminate extra display passes by paying attention to the</text> <br /><text>state of the library's input processing.</text> <br /><br /><text>The first of these benefits only requires interspersing calls to</text> <br /><text>jpeg_consume_input() with your display operations and any other processing</text> <br /><text>you may be doing. To avoid wasting cycles due to backtracking, it's best to</text> <br /><text>call jpeg_consume_input() only after a hundred or so new bytes have arrived.</text> <br /><text>This is discussed further under "I/O suspension", above. (Note: the JPEG</text> <br /><text>library currently is not thread-safe. You must not call jpeg_consume_input()</text> <br /><text>from one thread of control if a different library routine is working on the</text> <br /><text>same JPEG object in another thread.)</text> <br /><br /><text>When input arrives fast enough that more than one new scan is available</text> <br /><text>before you start a new output pass, you may as well skip the output pass</text> <br /><text>corresponding to the completed scan. This occurs for free if you pass</text> <br /><text>cinfo.input_scan_number as the target scan number to jpeg_start_output().</text> <br /><text>The input_scan_number field is simply the index of the scan currently being</text> <br /><text>consumed by the input processor. You can ensure that this is up-to-date by</text> <br /><text>emptying the input buffer just before calling jpeg_start_output(): call</text> <br /><text>jpeg_consume_input() repeatedly until it returns JPEG_SUSPENDED or</text> <br /><text>JPEG_REACHED_EOI.</text> <br /><br /><text>The target scan number passed to jpeg_start_output() is saved in the</text> <br /><text>cinfo.output_scan_number field. The library's output processing calls</text> <br /><text>jpeg_consume_input() whenever the current input scan number and row within</text> <br /><text>that scan is less than or equal to the current output scan number and row.</text> <br /><text>Thus, input processing can "get ahead" of the output processing but is not</text> <br /><text>allowed to "fall behind". You can achieve several different effects by</text> <br /><text>manipulating this interlock rule. For example, if you pass a target scan</text> <br /><text>number greater than the current input scan number, the output processor will</text> <br /><text>wait until that scan starts to arrive before producing any output. (To avoid</text> <br /><text>an infinite loop, the target scan number is automatically reset to the last</text> <br /><text>scan number when the end of image is reached. Thus, if you specify a large</text> <br /><text>target scan number, the library will just absorb the entire input file and</text> <br /><text>then perform an output pass. This is effectively the same as what</text> <br /><text>jpeg_start_decompress() does when you don't select buffered-image mode.)</text> <br /><text>When you pass a target scan number equal to the current input scan number,</text> <br /><text>the image is displayed no faster than the current input scan arrives. The</text> <br /><text>final possibility is to pass a target scan number less than the current input</text> <br /><text>scan number; this disables the input/output interlock and causes the output</text> <br /><text>processor to simply display whatever it finds in the image buffer, without</text> <br /><text>waiting for input. (However, the library will not accept a target scan</text> <br /><text>number less than one, so you can't avoid waiting for the first scan.)</text> <br /><br /><text>When data is arriving faster than the output display processing can advance</text> <br /><text>through the image, jpeg_consume_input() will store data into the buffered</text> <br /><text>image beyond the point at which the output processing is reading data out</text> <br /><text>again. If the input arrives fast enough, it may "wrap around" the buffer to</text> <br /><text>the point where the input is more than one whole scan ahead of the output.</text> <br /><text>If the output processing simply proceeds through its display pass without</text> <br /><text>paying attention to the input, the effect seen on-screen is that the lower</text> <br /><text>part of the image is one or more scans better in quality than the upper part.</text> <br /><text>Then, when the next output scan is started, you have a choice of what target</text> <br /><text>scan number to use. The recommended choice is to use the current input scan</text> <br /><text>number at that time, which implies that you've skipped the output scans</text> <br /><text>corresponding to the input scans that were completed while you processed the</text> <br /><text>previous output scan. In this way, the decoder automatically adapts its</text> <br /><text>speed to the arriving data, by skipping output scans as necessary to keep up</text> <br /><text>with the arriving data.</text> <br /><br /><text>When using this strategy, you'll want to be sure that you perform a final</text> <br /><text>output pass after receiving all the data; otherwise your last display may not</text> <br /><text>be full quality across the whole screen. So the right outer loop logic is</text> <br /><text>something like this:</text> <br /><text>do {</text> <br /><text>absorb any waiting input by calling jpeg_consume_input()</text> <br /><text>final_pass = jpeg_input_complete(&amp;cinfo);</text> <br /><text>adjust output decompression parameters if required</text> <br /><text>jpeg_start_output(&amp;cinfo, cinfo.input_scan_number);</text> <br /><text>...</text> <br /><text>jpeg_finish_output()</text> <br /><text>} while (! final_pass);</text> <br /><text>rather than quitting as soon as jpeg_input_complete() returns TRUE. This</text> <br /><text>arrangement makes it simple to use higher-quality decoding parameters</text> <br /><text>for the final pass. But if you don't want to use special parameters for</text> <br /><text>the final pass, the right loop logic is like this:</text> <br /><text>for (;;) {</text> <br /><text>absorb any waiting input by calling jpeg_consume_input()</text> <br /><text>jpeg_start_output(&amp;cinfo, cinfo.input_scan_number);</text> <br /><text>...</text> <br /><text>jpeg_finish_output()</text> <br /><text>if (jpeg_input_complete(&amp;cinfo) &amp;&amp;</text> <br /><text>cinfo.input_scan_number == cinfo.output_scan_number)</text> <br /><text>break;</text> <br /><text>}</text> <br /><text>In this case you don't need to know in advance whether an output pass is to</text> <br /><text>be the last one, so it's not necessary to have reached EOF before starting</text> <br /><text>the final output pass; rather, what you want to test is whether the output</text> <br /><text>pass was performed in sync with the final input scan. This form of the loop</text> <br /><text>will avoid an extra output pass whenever the decoder is able (or nearly able)</text> <br /><text>to keep up with the incoming data.</text> <br /><br /><text>When the data transmission speed is high, you might begin a display pass,</text> <br /><text>then find that much or all of the file has arrived before you can complete</text> <br /><text>the pass. (You can detect this by noting the JPEG_REACHED_EOI return code</text> <br /><text>from jpeg_consume_input(), or equivalently by testing jpeg_input_complete().)</text> <br /><text>In this situation you may wish to abort the current display pass and start a</text> <br /><text>new one using the newly arrived information. To do so, just call</text> <br /><text>jpeg_finish_output() and then start a new pass with jpeg_start_output().</text> <br /><br /><text>A variant strategy is to abort and restart display if more than one complete</text> <br /><text>scan arrives during an output pass; this can be detected by noting</text> <br /><text>JPEG_REACHED_SOS returns and/or examining cinfo.input_scan_number. This</text> <br /><text>idea should be employed with caution, however, since the display process</text> <br /><text>might never get to the bottom of the image before being aborted, resulting</text> <br /><text>in the lower part of the screen being several passes worse than the upper.</text> <br /><text>In most cases it's probably best to abort an output pass only if the whole</text> <br /><text>file has arrived and you want to begin the final output pass immediately.</text> <br /><br /><text>When receiving data across a communication link, we recommend always using</text> <br /><text>the current input scan number for the output target scan number; if a</text> <br /><text>higher-quality final pass is to be done, it should be started (aborting any</text> <br /><text>incomplete output pass) as soon as the end of file is received. However,</text> <br /><text>many other strategies are possible. For example, the application can examine</text> <br /><text>the parameters of the current input scan and decide whether to display it or</text> <br /><text>not. If the scan contains only chroma data, one might choose not to use it</text> <br /><text>as the target scan, expecting that the scan will be small and will arrive</text> <br /><text>quickly. To skip to the next scan, call jpeg_consume_input() until it</text> <br /><text>returns JPEG_REACHED_SOS or JPEG_REACHED_EOI. Or just use the next higher</text> <br /><text>number as the target scan for jpeg_start_output(); but that method doesn't</text> <br /><text>let you inspect the next scan's parameters before deciding to display it.</text> <br /><br /><br /><text>In buffered-image mode, jpeg_start_decompress() never performs input and</text> <br /><text>thus never suspends. An application that uses input suspension with</text> <br /><text>buffered-image mode must be prepared for suspension returns from these</text> <br /><text>routines:</text> <br /><text>* jpeg_start_output() performs input only if you request 2-pass quantization</text> <br /><text>and the target scan isn't fully read yet. (This is discussed below.)</text> <br /><text>* jpeg_read_scanlines(), as always, returns the number of scanlines that it</text> <br /><text>was able to produce before suspending.</text> <br /><text>* jpeg_finish_output() will read any markers following the target scan,</text> <br /><text>up to the end of the file or the SOS marker that begins another scan.</text> <br /><text>(But it reads no input if jpeg_consume_input() has already reached the</text> <br /><text>end of the file or a SOS marker beyond the target output scan.)</text> <br /><text>* jpeg_finish_decompress() will read until the end of file, and thus can</text> <br /><text>suspend if the end hasn't already been reached (as can be tested by</text> <br /><text>calling jpeg_input_complete()).</text> <br /><text>jpeg_start_output(), jpeg_finish_output(), and jpeg_finish_decompress()</text> <br /><text>all return TRUE if they completed their tasks, FALSE if they had to suspend.</text> <br /><text>In the event of a FALSE return, the application must load more input data</text> <br /><text>and repeat the call. Applications that use non-suspending data sources need</text> <br /><text>not check the return values of these three routines.</text> <br /><br /><br /><text>It is possible to change decoding parameters between output passes in the</text> <br /><text>buffered-image mode. The decoder library currently supports only very</text> <br /><text>limited changes of parameters. ONLY THE FOLLOWING parameter changes are</text> <br /><text>allowed after jpeg_start_decompress() is called:</text> <br /><text>* dct_method can be changed before each call to jpeg_start_output().</text> <br /><text>For example, one could use a fast DCT method for early scans, changing</text> <br /><text>to a higher quality method for the final scan.</text> <br /><text>* dither_mode can be changed before each call to jpeg_start_output();</text> <br /><text>of course this has no impact if not using color quantization. Typically</text> <br /><text>one would use ordered dither for initial passes, then switch to</text> <br /><text>Floyd-Steinberg dither for the final pass. Caution: changing dither mode</text> <br /><text>can cause more memory to be allocated by the library. Although the amount</text> <br /><text>of memory involved is not large (a scanline or so), it may cause the</text> <br /><text>initial max_memory_to_use specification to be exceeded, which in the worst</text> <br /><text>case would result in an out-of-memory failure.</text> <br /><text>* do_block_smoothing can be changed before each call to jpeg_start_output().</text> <br /><text>This setting is relevant only when decoding a progressive JPEG image.</text> <br /><text>During the first DC-only scan, block smoothing provides a very "fuzzy" look</text> <br /><text>instead of the very "blocky" look seen without it; which is better seems a</text> <br /><text>matter of personal taste. But block smoothing is nearly always a win</text> <br /><text>during later stages, especially when decoding a successive-approximation</text> <br /><text>image: smoothing helps to hide the slight blockiness that otherwise shows</text> <br /><text>up on smooth gradients until the lowest coefficient bits are sent.</text> <br /><text>* Color quantization mode can be changed under the rules described below.</text> <br /><text>You *cannot* change between full-color and quantized output (because that</text> <br /><text>would alter the required I/O buffer sizes), but you can change which</text> <br /><text>quantization method is used.</text> <br /><br /><text>When generating color-quantized output, changing quantization method is a</text> <br /><text>very useful way of switching between high-speed and high-quality display.</text> <br /><text>The library allows you to change among its three quantization methods:</text> <br /><text>1. Single-pass quantization to a fixed color cube.</text> <br /><text>Selected by cinfo.two_pass_quantize = FALSE and cinfo.colormap = NULL.</text> <br /><text>2. Single-pass quantization to an application-supplied colormap.</text> <br /><text>Selected by setting cinfo.colormap to point to the colormap (the value of</text> <br /><text>two_pass_quantize is ignored); also set cinfo.actual_number_of_colors.</text> <br /><text>3. Two-pass quantization to a colormap chosen specifically for the image.</text> <br /><text>Selected by cinfo.two_pass_quantize = TRUE and cinfo.colormap = NULL.</text> <br /><text>(This is the default setting selected by jpeg_read_header, but it is</text> <br /><text>probably NOT what you want for the first pass of progressive display!)</text> <br /><text>These methods offer successively better quality and lesser speed. However,</text> <br /><text>only the first method is available for quantizing in non-RGB color spaces.</text> <br /><br /><text>IMPORTANT: because the different quantizer methods have very different</text> <br /><text>working-storage requirements, the library requires you to indicate which</text> <br /><text>one(s) you intend to use before you call jpeg_start_decompress(). (If we did</text> <br /><text>not require this, the max_memory_to_use setting would be a complete fiction.)</text> <br /><text>You do this by setting one or more of these three cinfo fields to TRUE:</text> <br /><text>enable_1pass_quant Fixed color cube colormap</text> <br /><text>enable_external_quant Externally-supplied colormap</text> <br /><text>enable_2pass_quant Two-pass custom colormap</text> <br /><text>All three are initialized FALSE by jpeg_read_header(). But</text> <br /><text>jpeg_start_decompress() automatically sets TRUE the one selected by the</text> <br /><text>current two_pass_quantize and colormap settings, so you only need to set the</text> <br /><text>enable flags for any other quantization methods you plan to change to later.</text> <br /><br /><text>After setting the enable flags correctly at jpeg_start_decompress() time, you</text> <br /><text>can change to any enabled quantization method by setting two_pass_quantize</text> <br /><text>and colormap properly just before calling jpeg_start_output(). The following</text> <br /><text>special rules apply:</text> <br /><text>1. You must explicitly set cinfo.colormap to NULL when switching to 1-pass</text> <br /><text>or 2-pass mode from a different mode, or when you want the 2-pass</text> <br /><text>quantizer to be re-run to generate a new colormap.</text> <br /><text>2. To switch to an external colormap, or to change to a different external</text> <br /><text>colormap than was used on the prior pass, you must call</text> <br /><text>jpeg_new_colormap() after setting cinfo.colormap.</text> <br /><text>NOTE: if you want to use the same colormap as was used in the prior pass,</text> <br /><text>you should not do either of these things. This will save some nontrivial</text> <br /><text>switchover costs.</text> <br /><text>(These requirements exist because cinfo.colormap will always be non-NULL</text> <br /><text>after completing a prior output pass, since both the 1-pass and 2-pass</text> <br /><text>quantizers set it to point to their output colormaps. Thus you have to</text> <br /><text>do one of these two things to notify the library that something has changed.</text> <br /><text>Yup, it's a bit klugy, but it's necessary to do it this way for backwards</text> <br /><text>compatibility.)</text> <br /><br /><text>Note that in buffered-image mode, the library generates any requested colormap</text> <br /><text>during jpeg_start_output(), not during jpeg_start_decompress().</text> <br /><br /><text>When using two-pass quantization, jpeg_start_output() makes a pass over the</text> <br /><text>buffered image to determine the optimum color map; it therefore may take a</text> <br /><text>significant amount of time, whereas ordinarily it does little work. The</text> <br /><text>progress monitor hook is called during this pass, if defined. It is also</text> <br /><text>important to realize that if the specified target scan number is greater than</text> <br /><text>or equal to the current input scan number, jpeg_start_output() will attempt</text> <br /><text>to consume input as it makes this pass. If you use a suspending data source,</text> <br /><text>you need to check for a FALSE return from jpeg_start_output() under these</text> <br /><text>conditions. The combination of 2-pass quantization and a not-yet-fully-read</text> <br /><text>target scan is the only case in which jpeg_start_output() will consume input.</text> <br /><br /><br /><text>Application authors who support buffered-image mode may be tempted to use it</text> <br /><text>for all JPEG images, even single-scan ones. This will work, but it is</text> <br /><text>inefficient: there is no need to create an image-sized coefficient buffer for</text> <br /><text>single-scan images. Requesting buffered-image mode for such an image wastes</text> <br /><text>memory. Worse, it can cost time on large images, since the buffered data has</text> <br /><text>to be swapped out or written to a temporary file. If you are concerned about</text> <br /><text>maximum performance on baseline JPEG files, you should use buffered-image</text> <br /><text>mode only when the incoming file actually has multiple scans. This can be</text> <br /><text>tested by calling jpeg_has_multiple_scans(), which will return a correct</text> <br /><text>result at any time after jpeg_read_header() completes.</text> <br /><br /><text>It is also worth noting that when you use jpeg_consume_input() to let input</text> <br /><text>processing get ahead of output processing, the resulting pattern of access to</text> <br /><text>the coefficient buffer is quite nonsequential. It's best to use the memory</text> <br /><text>manager jmemnobs.c if you can (ie, if you have enough real or virtual main</text> <br /><text>memory). If not, at least make sure that max_memory_to_use is set as high as</text> <br /><text>possible. If the JPEG memory manager has to use a temporary file, you will</text> <br /><text>probably see a lot of disk traffic and poor performance. (This could be</text> <br /><text>improved with additional work on the memory manager, but we haven't gotten</text> <br /><text>around to it yet.)</text> <br /><br /><text>In some applications it may be convenient to use jpeg_consume_input() for all</text> <br /><text>input processing, including reading the initial markers; that is, you may</text> <br /><text>wish to call jpeg_consume_input() instead of jpeg_read_header() during</text> <br /><text>startup. This works, but note that you must check for JPEG_REACHED_SOS and</text> <br /><text>JPEG_REACHED_EOI return codes as the equivalent of jpeg_read_header's codes.</text> <br /><text>Once the first SOS marker has been reached, you must call</text> <br /><text>jpeg_start_decompress() before jpeg_consume_input() will consume more input;</text> <br /><text>it'll just keep returning JPEG_REACHED_SOS until you do. If you read a</text> <br /><text>tables-only file this way, jpeg_consume_input() will return JPEG_REACHED_EOI</text> <br /><text>without ever returning JPEG_REACHED_SOS; be sure to check for this case.</text> <br /><text>If this happens, the decompressor will not read any more input until you call</text> <br /><text>jpeg_abort() to reset it. It is OK to call jpeg_consume_input() even when not</text> <br /><text>using buffered-image mode, but in that case it's basically a no-op after the</text> <br /><text>initial markers have been read: it will just return JPEG_SUSPENDED.</text> <br /></descriptionarticle>
  </file>
</xml>