<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Buffered-image mode</title>
    <breadcumbs>
      <link file="..\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <text>In buffered-image mode, the library stores the partially decoded image in a coefficient buffer, from which it can be read out as many times as desired. This mode is typically used for incremental display of progressive JPEG files, but it can be used with any JPEG file. Each scan of a progressive JPEG file adds more data (more detail) to the buffered image. The application can display in lockstep with the source file (one display pass per input scan), or it can allow input processing to outrun display processing. By making</text> <br /><text>input and display processing run independently, it is possible for the application to adapt progressive display to a wide range of data transmission rates.</text> <br /><br /><text>The basic control flow for buffered-image decoding is:</text> </p>
      <p>
        <i>
          <text>Allocate and initialize a JPEG decompression object</text> <br /><text>Set data source</text> <br /><link file="../jpeg_decompress_struct.jpeg_read_header.xml"><text>jpeg_read_header</text> </link><text>()</text> <br /><text>set overall decompression parameters</text> <br /><text>cinfo.</text> <link file="../jpeg_decompress_struct.Buffered_image.xml"><text>Buffered_image</text> </link><text> = true; /* select buffered-image mode */</text> <br /><link file="../jpeg_decompress_struct.jpeg_start_decompress.xml"><text>jpeg_start_decompress</text> </link><text>()</text> <br /><text>for (each output pass)</text> <br /><text>{</text> <br /><text>    adjust output decompression parameters if required</text> <br /><text>    </text> <link file="../jpeg_decompress_struct.jpeg_start_output.xml"><text>jpeg_start_output</text> </link><text>() /* start a new output pass */</text> <br /><text>    for (all scanlines in image)</text> <br /><text>    {</text> <br /><text>        </text> <link file="../jpeg_decompress_struct.jpeg_read_scanlines.xml"><text>jpeg_read_scanlines</text> </link><text>()</text> <br /><text>        display scanlines</text> <br /><text>    }</text> <br /><text>    </text> <link file="../jpeg_decompress_struct.jpeg_finish_output.xml"><text>jpeg_finish_output</text> </link><text>() /* terminate output pass */</text> <br /><text>}</text> <br /><link file="../jpeg_decompress_struct.jpeg_finish_decompress.xml"><text>jpeg_finish_decompress</text> </link><text>()</text> <br /></i>
        <br />
        <text>This differs from ordinary unbuffered decoding in that there is an additional level of looping. The application can choose how many output passes to make and how to display each pass.</text> <br /><br /><text>The simplest approach to displaying progressive images is to do one display pass for each scan appearing in the input file. In this case the outer loop condition is typically:</text> </p>
      <p>
        <i>
          <text>while (!cinfo.</text> <link file="../jpeg_decompress_struct.jpeg_input_complete.xml"><text>jpeg_input_complete</text> </link><text>())</text> </i>
      </p>
      <p>
        <text>and the start-output call should read</text> </p>
      <p>
        <i>
          <text>cinfo.</text> <link file="../jpeg_decompress_struct.jpeg_start_output.xml"><text>jpeg_start_output</text> </link><text>(cinfo.Input_scan_number)</text> </i>
        <text>;</text> </p>
      <p>
        <text>Alternative solution - you can use a loop counter starting at 1 if you like. The library automatically reads data as necessary to complete each requested scan, and </text> <link file="../jpeg_decompress_struct.jpeg_finish_output.xml"><text>jpeg_finish_output</text> </link><text>() advances to the next scan or end-of-image marker (hence </text> <link file="../jpeg_decompress_struct.Input_scan_number.xml"><text>Input_scan_number</text> </link><text> will be incremented by the time control arrives back at jpeg_start_output()). With this technique, data is read from the input file only as needed, and input and output processing run in lockstep.</text> <br /><br /><text>After reading the final scan and reaching the end of the input file, the buffered image remains available; it can be read additional times by repeating the jpeg_start_output()/jpeg_read_scanlines()/jpeg_finish_output() sequence. For example, a useful technique is to use fast one-pass color quantization for display passes made while the image is arriving, followed by a final display pass using two-pass quantization for highest quality. This is done by changing the library parameters before the final output pass. Changing parameters between passes is discussed in detail below.</text> <br /><br /><text>In general the last scan of a progressive file cannot be recognized as such until after it is read, so a post-input display pass is the best approach if you want special processing in the final pass.</text> <br /><br /><text>When done with the image, be sure to call </text> <link file="../jpeg_decompress_struct.jpeg_finish_decompress.xml"><text>jpeg_finish_decompress</text> </link><text>() to release the buffered image.</text> <br /><br /><text>If input data arrives faster than it can be displayed, the application can cause the library to decode input data in advance of what's needed to produce output. This is done by calling the routine </text> <link file="../jpeg_decompress_struct.jpeg_consume_input.xml"><text>jpeg_consume_input</text> </link><text>(). This routine reads some additional data and returns when one of the indicated significant events occurs.</text> <br /><br /><text>The library's output processing will automatically call jpeg_consume_input() whenever the output processing overtakes the input; thus, simple lockstep display requires no direct calls to jpeg_consume_input(). But by adding calls to jpeg_consume_input(), you can absorb data in advance of what is being displayed. This has two benefits:</text> <br /><text>* You can limit buildup of unprocessed data in your input buffer.</text> <br /><text>* You can eliminate extra display passes by paying attention to the state of the library's input processing.</text> <br /><br /><text>The first of these benefits only requires interspersing calls to </text> <link file="../jpeg_decompress_struct.jpeg_consume_input.xml"><text>jpeg_consume_input</text> </link><text>() with your display operations and any other processing you may be doing. To avoid wasting cycles due to backtracking, it's best to call jpeg_consume_input() only after a hundred or so new bytes have arrived.</text> <br /><text>Note: the JPEG library currently is not thread-safe. You must not call jpeg_consume_input() from one thread of control if a different library routine is working on the same JPEG object in another thread.</text> <br /><br /><text>When input arrives fast enough that more than one new scan is available before you start a new output pass, you may as well skip the output pass corresponding to the completed scan. This occurs for free if you pass cinfo.</text> <link file="../jpeg_decompress_struct.Input_scan_number.xml"><text>Input_scan_number</text> </link><text> as the target scan number to </text> <link file="../jpeg_decompress_struct.jpeg_start_output.xml"><text>jpeg_start_output</text> </link><text>().</text> <br /><text>The input_scan_number field is simply the index of the scan currently being consumed by the input processor. You can ensure that this is up-to-date by emptying the input buffer just before calling jpeg_start_output(): call jpeg_consume_input() repeatedly until it returns JPEG_SUSPENDED or JPEG_REACHED_EOI.</text> <br /><br /><text>The target scan number passed to jpeg_start_output() is saved in the cinfo.output_scan_number field. The library's output processing calls jpeg_consume_input() whenever the current input scan number and row within that scan is less than or equal to the current output scan number and row. Thus, input processing can "get ahead" of the output processing but is not allowed to "fall behind". You can achieve several different effects by manipulating this interlock rule. For example, if you pass a target scan number greater than the current input scan number, the output processor will wait until that scan starts to arrive before producing any output. (To avoid an infinite loop, the target scan number is automatically reset to the last scan number when the end of image is reached. Thus, if you specify a large target scan number, the library will just absorb the entire input file and then perform an output pass. This is effectively the same as what jpeg_start_decompress() does when you don't select buffered-image mode.)</text> <br /><text>When you pass a target scan number equal to the current input scan number, the image is displayed no faster than the current input scan arrives. The final possibility is to pass a target scan number less than the current input scan number; this disables the input/output interlock and causes the output processor to simply display whatever it finds in the image buffer, without waiting for input. (However, the library will not accept a target scan number less than one, so you can't avoid waiting for the first scan.)</text> <br /><br /><text>When data is arriving faster than the output display processing can advance through the image, jpeg_consume_input() will store data into the buffered image beyond the point at which the output processing is reading data out again. If the input arrives fast enough, it may "wrap around" the buffer to the point where the input is more than one whole scan ahead of the output. If the output processing simply proceeds through its display pass without paying attention to the input, the effect seen on-screen is that the lower part of the image is one or more scans better in quality than the upper part. Then, when the next output scan is started, you have a choice of what target scan number to use. The recommended choice is to use the current input scan number at that time, which implies that you've skipped the output scans corresponding to the input scans that were completed while you processed the previous output scan. In this way, the decoder automatically adapts its speed to the arriving data, by skipping output scans as necessary to keep up with the arriving data.</text> <br /><br /><text>When using this strategy, you'll want to be sure that you perform a final output pass after receiving all the data; otherwise your last display may not be full quality across the whole screen. So the right outer loop logic is something like this:</text> </p>
      <p>
        <i>
          <text>do {</text> <br /><text>absorb any waiting input by calling jpeg_consume_input()</text> <br /><text>final_pass = jpeg_input_complete(&amp;cinfo);</text> <br /><text>adjust output decompression parameters if required</text> <br /><text>jpeg_start_output(&amp;cinfo, cinfo.input_scan_number);</text> <br /><text>...</text> <br /><text>jpeg_finish_output()</text> <br /><text>} while (! final_pass);</text> </i>
      </p>
      <p>
        <text>rather than quitting as soon as jpeg_input_complete() returns TRUE. This arrangement makes it simple to use higher-quality decoding parameters for the final pass. But if you don't want to use special parameters for the final pass, the right loop logic is like this:</text> </p>
      <p>
        <i>
          <text>for (;;) {</text> <br /><text>absorb any waiting input by calling jpeg_consume_input()</text> <br /><text>jpeg_start_output(&amp;cinfo, cinfo.input_scan_number);</text> <br /><text>...</text> <br /><text>jpeg_finish_output()</text> <br /><text>if (jpeg_input_complete(&amp;cinfo) &amp;&amp;</text> <br /><text>cinfo.input_scan_number == cinfo.output_scan_number)</text> <br /><text>break;</text> <br /><text>}</text> </i>
      </p>
      <p>
        <text>In this case you don't need to know in advance whether an output pass is to be the last one, so it's not necessary to have reached EOF before starting the final output pass; rather, what you want to test is whether the output pass was performed in sync with the final input scan. This form of the loop will avoid an extra output pass whenever the decoder is able (or nearly able) to keep up with the incoming data.</text> <br /><br /><text>When the data transmission speed is high, you might begin a display pass, then find that much or all of the file has arrived before you can complete the pass. (You can detect this by noting the JPEG_REACHED_EOI return code from jpeg_consume_input(), or equivalently by testing jpeg_input_complete().)</text> <br /><text>In this situation you may wish to abort the current display pass and start a new one using the newly arrived information. To do so, just call jpeg_finish_output() and then start a new pass with jpeg_start_output().</text> <br /><br /><text>A variant strategy is to abort and restart display if more than one complete scan arrives during an output pass; this can be detected by noting JPEG_REACHED_SOS returns and/or examining cinfo.input_scan_number. This idea should be employed with caution, however, since the display process might never get to the bottom of the image before being aborted, resulting in the lower part of the screen being several passes worse than the upper.</text> <br /><text>In most cases it's probably best to abort an output pass only if the whole file has arrived and you want to begin the final output pass immediately.</text> <br /><br /><text>When receiving data across a communication link, we recommend always using the current input scan number for the output target scan number; if a higher-quality final pass is to be done, it should be started (aborting any incomplete output pass) as soon as the end of file is received. However, many other strategies are possible. For example, the application can examine the parameters of the current input scan and decide whether to display it or not. If the scan contains only chroma data, one might choose not to use it as the target scan, expecting that the scan will be small and will arrive quickly. To skip to the next scan, call jpeg_consume_input() until it returns JPEG_REACHED_SOS or JPEG_REACHED_EOI. Or just use the next higher number as the target scan for jpeg_start_output(); but that method doesn't let you inspect the next scan's parameters before deciding to display it.</text> <br /><br /><text>In buffered-image mode, jpeg_start_decompress() never performs input and thus never suspends. An application that uses input suspension with buffered-image mode must be prepared for suspension returns from these routines:</text> <br /><text>* jpeg_start_output() performs input only if you request 2-pass quantization and the target scan isn't fully read yet. (This is discussed below.)</text> <br /><text>* jpeg_read_scanlines(), as always, returns the number of scanlines that it was able to produce before suspending.</text> <br /><text>* jpeg_finish_output() will read any markers following the target scan, up to the end of the file or the SOS marker that begins another scan.</text> <br /><text>(But it reads no input if jpeg_consume_input() has already reached the end of the file or a SOS marker beyond the target output scan.)</text> <br /><text>* jpeg_finish_decompress() will read until the end of file, and thus can suspend if the end hasn't already been reached (as can be tested by calling jpeg_input_complete()).</text> <br /><text>jpeg_start_output(), jpeg_finish_output(), and jpeg_finish_decompress() all return </text> <b><text>true</text> </b><text> if they completed their tasks, </text> <b><text>false</text> </b><text> if they had to suspend.</text> <br /><text>In the event of a FALSE return, the application must load more input data and repeat the call. Applications that use non-suspending data sources need not check the return values of these three routines.</text> <br /><br /><text>It is possible to change decoding parameters between output passes in the buffered-image mode. The decoder library currently supports only very limited changes of parameters. ONLY THE FOLLOWING parameter changes are allowed after </text> <link file="../jpeg_decompress_struct.jpeg_start_decompress.xml"><text>jpeg_start_decompress</text> </link><text>() is called:</text> <br /><text>* dct_method can be changed before each call to jpeg_start_output(). For example, one could use a fast DCT method for early scans, changing to a higher quality method for the final scan.</text> <br /><text>* dither_mode can be changed before each call to jpeg_start_output();</text> <br /><text>of course this has no impact if not using color quantization. Typically</text> <br /><text>one would use ordered dither for initial passes, then switch to</text> <br /><text>Floyd-Steinberg dither for the final pass. Caution: changing dither mode</text> <br /><text>can cause more memory to be allocated by the library. Although the amount</text> <br /><text>of memory involved is not large (a scanline or so), it may cause the</text> <br /><text>initial max_memory_to_use specification to be exceeded, which in the worst</text> <br /><text>case would result in an out-of-memory failure.</text> <br /><text>* do_block_smoothing can be changed before each call to jpeg_start_output().</text> <br /><text>This setting is relevant only when decoding a progressive JPEG image.</text> <br /><text>During the first DC-only scan, block smoothing provides a very "fuzzy" look</text> <br /><text>instead of the very "blocky" look seen without it; which is better seems a</text> <br /><text>matter of personal taste. But block smoothing is nearly always a win</text> <br /><text>during later stages, especially when decoding a successive-approximation</text> <br /><text>image: smoothing helps to hide the slight blockiness that otherwise shows</text> <br /><text>up on smooth gradients until the lowest coefficient bits are sent.</text> <br /><text>* Color quantization mode can be changed under the rules described below.</text> <br /><text>You *cannot* change between full-color and quantized output (because that</text> <br /><text>would alter the required I/O buffer sizes), but you can change which</text> <br /><text>quantization method is used.</text> <br /><br /><text>When generating color-quantized output, changing quantization method is a</text> <br /><text>very useful way of switching between high-speed and high-quality display.</text> <br /><text>The library allows you to change among its three quantization methods:</text> <br /><text>1. Single-pass quantization to a fixed color cube.</text> <br /><text>Selected by cinfo.two_pass_quantize = FALSE and cinfo.colormap = NULL.</text> <br /><text>2. Single-pass quantization to an application-supplied colormap.</text> <br /><text>Selected by setting cinfo.colormap to point to the colormap (the value of</text> <br /><text>two_pass_quantize is ignored); also set cinfo.actual_number_of_colors.</text> <br /><text>3. Two-pass quantization to a colormap chosen specifically for the image.</text> <br /><text>Selected by cinfo.two_pass_quantize = TRUE and cinfo.colormap = NULL.</text> <br /><text>(This is the default setting selected by jpeg_read_header, but it is</text> <br /><text>probably NOT what you want for the first pass of progressive display!)</text> <br /><text>These methods offer successively better quality and lesser speed. However,</text> <br /><text>only the first method is available for quantizing in non-RGB color spaces.</text> <br /><br /><text>IMPORTANT: because the different quantizer methods have very different</text> <br /><text>working-storage requirements, the library requires you to indicate which</text> <br /><text>one(s) you intend to use before you call jpeg_start_decompress(). (If we did</text> <br /><text>not require this, the max_memory_to_use setting would be a complete fiction.)</text> <br /><text>You do this by setting one or more of these three cinfo fields to TRUE:</text> <br /><text>enable_1pass_quant Fixed color cube colormap</text> <br /><text>enable_external_quant Externally-supplied colormap</text> <br /><text>enable_2pass_quant Two-pass custom colormap</text> <br /><text>All three are initialized FALSE by jpeg_read_header(). But</text> <br /><text>jpeg_start_decompress() automatically sets TRUE the one selected by the</text> <br /><text>current two_pass_quantize and colormap settings, so you only need to set the</text> <br /><text>enable flags for any other quantization methods you plan to change to later.</text> <br /><br /><text>After setting the enable flags correctly at jpeg_start_decompress() time, you</text> <br /><text>can change to any enabled quantization method by setting two_pass_quantize</text> <br /><text>and colormap properly just before calling jpeg_start_output(). The following</text> <br /><text>special rules apply:</text> <br /><text>1. You must explicitly set cinfo.colormap to NULL when switching to 1-pass</text> <br /><text>or 2-pass mode from a different mode, or when you want the 2-pass</text> <br /><text>quantizer to be re-run to generate a new colormap.</text> <br /><text>2. To switch to an external colormap, or to change to a different external</text> <br /><text>colormap than was used on the prior pass, you must call</text> <br /><text>jpeg_new_colormap() after setting cinfo.colormap.</text> <br /><text>NOTE: if you want to use the same colormap as was used in the prior pass,</text> <br /><text>you should not do either of these things. This will save some nontrivial</text> <br /><text>switchover costs.</text> <br /><text>(These requirements exist because cinfo.colormap will always be non-NULL</text> <br /><text>after completing a prior output pass, since both the 1-pass and 2-pass</text> <br /><text>quantizers set it to point to their output colormaps. Thus you have to</text> <br /><text>do one of these two things to notify the library that something has changed.</text> <br /><text>Yup, it's a bit klugy, but it's necessary to do it this way for backwards</text> <br /><text>compatibility.)</text> <br /><br /><text>Note that in buffered-image mode, the library generates any requested colormap</text> <br /><text>during jpeg_start_output(), not during jpeg_start_decompress().</text> <br /><br /><text>When using two-pass quantization, jpeg_start_output() makes a pass over the</text> <br /><text>buffered image to determine the optimum color map; it therefore may take a</text> <br /><text>significant amount of time, whereas ordinarily it does little work. The</text> <br /><text>progress monitor hook is called during this pass, if defined. It is also</text> <br /><text>important to realize that if the specified target scan number is greater than</text> <br /><text>or equal to the current input scan number, jpeg_start_output() will attempt</text> <br /><text>to consume input as it makes this pass. If you use a suspending data source,</text> <br /><text>you need to check for a FALSE return from jpeg_start_output() under these</text> <br /><text>conditions. The combination of 2-pass quantization and a not-yet-fully-read</text> <br /><text>target scan is the only case in which jpeg_start_output() will consume input.</text> <br /><br /><br /><text>Application authors who support buffered-image mode may be tempted to use it</text> <br /><text>for all JPEG images, even single-scan ones. This will work, but it is</text> <br /><text>inefficient: there is no need to create an image-sized coefficient buffer for</text> <br /><text>single-scan images. Requesting buffered-image mode for such an image wastes</text> <br /><text>memory. Worse, it can cost time on large images, since the buffered data has</text> <br /><text>to be swapped out or written to a temporary file. If you are concerned about</text> <br /><text>maximum performance on baseline JPEG files, you should use buffered-image</text> <br /><text>mode only when the incoming file actually has multiple scans. This can be</text> <br /><text>tested by calling jpeg_has_multiple_scans(), which will return a correct</text> <br /><text>result at any time after jpeg_read_header() completes.</text> <br /><br /><text>It is also worth noting that when you use jpeg_consume_input() to let input</text> <br /><text>processing get ahead of output processing, the resulting pattern of access to</text> <br /><text>the coefficient buffer is quite nonsequential. It's best to use the memory</text> <br /><text>manager jmemnobs.c if you can (ie, if you have enough real or virtual main</text> <br /><text>memory). If not, at least make sure that max_memory_to_use is set as high as</text> <br /><text>possible. If the JPEG memory manager has to use a temporary file, you will</text> <br /><text>probably see a lot of disk traffic and poor performance. (This could be</text> <br /><text>improved with additional work on the memory manager, but we haven't gotten</text> <br /><text>around to it yet.)</text> <br /><br /><text>In some applications it may be convenient to use jpeg_consume_input() for all</text> <br /><text>input processing, including reading the initial markers; that is, you may</text> <br /><text>wish to call jpeg_consume_input() instead of jpeg_read_header() during</text> <br /><text>startup. This works, but note that you must check for JPEG_REACHED_SOS and</text> <br /><text>JPEG_REACHED_EOI return codes as the equivalent of jpeg_read_header's codes.</text> <br /><text>Once the first SOS marker has been reached, you must call</text> <br /><text>jpeg_start_decompress() before jpeg_consume_input() will consume more input;</text> <br /><text>it'll just keep returning JPEG_REACHED_SOS until you do. If you read a</text> <br /><text>tables-only file this way, jpeg_consume_input() will return JPEG_REACHED_EOI</text> <br /><text>without ever returning JPEG_REACHED_SOS; be sure to check for this case.</text> <br /><text>If this happens, the decompressor will not read any more input until you call</text> <br /><text>jpeg_abort() to reset it. It is OK to call jpeg_consume_input() even when not</text> <br /><text>using buffered-image mode, but in that case it's basically a no-op after the</text> <br /><text>initial markers have been read: it will just return JPEG_SUSPENDED.</text> <br /></p>
    </descriptionarticle>
  </file>
</xml>