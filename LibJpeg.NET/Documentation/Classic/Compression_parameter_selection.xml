<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Compression parameter selection</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <text>This section describes all the optional parameters you can set for JPEG compression, as well as the "helper" routines provided to assist in this task. Proper setting of some parameters requires detailed understanding of the JPEG standard; if you don't know what a parameter is for, it's best not to mess with it!</text> <br /><br /><text>It's a good idea to call </text> <link file="../jpeg_compress_struct.jpeg_set_defaults.xml"><text>jpeg_set_defaults</text> </link><text>() first, even if you plan to set all the parameters; that way your code is more likely to work with future JPEG libraries that have additional parameters. For the same reason, we recommend you use a helper routine where one is provided, in preference to twiddling cinfo properties directly.</text> <br /><br /><text>The helper routines are:</text> </p>
      <p>
        <table>
          <tbody>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.jpeg_set_defaults.xml">
                  <text>jpeg_set_defaults</text> </link>
              </td>
              <td>
                <text>Sets all JPEG parameters to reasonable defaults, using</text> <br /><text>only the </text> <link file="../jpeg_compress_struct.In_color_space.xml"><text>input image's color space</text> </link><text>.</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.jpeg_set_colorspace.xml">
                  <text>jpeg_set_colorspace</text> </link>
              </td>
              <td>
                <text>Sets the JPEG file's colorspace as specified, and sets other colorspace-dependent parameters appropriately.</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.jpeg_default_colorspace.xml">
                  <text>jpeg_default_colorspace</text> </link>
              </td>
              <td>
                <text>Selects an appropriate JPEG colorspace based on </text> <link file="../jpeg_compress_struct.In_color_space.xml"><text>In_color_space</text> </link><text>, and calls </text> <link file="../jpeg_compress_struct.jpeg_set_colorspace.xml"><text>jpeg_set_colorspace</text> </link><text>().</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.jpeg_set_quality.xml">
                  <text>jpeg_set_quality</text> </link>
              </td>
              <td>
                <text>Constructs JPEG quantization tables appropriate for the indicated quality setting.</text> </td>
            </tr>
          </tbody>
        </table>
        <br />
        <text>jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,</text> <br /><text>boolean force_baseline)</text> <br /><text>Same as jpeg_set_quality() except that the generated tables are the</text> <br /><text>sample tables given in the JPEC spec section K.1, multiplied by the</text> <br /><text>specified scale factor (which is expressed as a percentage; thus</text> <br /><text>scale_factor = 100 reproduces the spec's tables). Note that larger</text> <br /><text>scale factors give lower quality. This entry point is useful for</text> <br /><text>conforming to the Adobe PostScript DCT conventions, but we do not</text> <br /><text>recommend linear scaling as a user-visible quality scale otherwise.</text> <br /><text>force_baseline again constrains the computed table entries to 1..255.</text> <br /><br /><text>int jpeg_quality_scaling (int quality)</text> <br /><text>Converts a value on the IJG-recommended quality scale to a linear</text> <br /><text>scaling percentage. Note that this routine may change or go away</text> <br /><text>in future releases --- IJG may choose to adopt a scaling method that</text> <br /><text>can't be expressed as a simple scalar multiplier, in which case the</text> <br /><text>premise of this routine collapses. Caveat user.</text> <br /><br /><text>jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,</text> <br /><text>const unsigned int *basic_table,</text> <br /><text>int scale_factor, boolean force_baseline)</text> <br /><text>Allows an arbitrary quantization table to be created. which_tbl</text> <br /><text>indicates which table slot to fill. basic_table points to an array</text> <br /><text>of 64 unsigned ints given in normal array order. These values are</text> <br /><text>multiplied by scale_factor/100 and then clamped to the range 1..65535</text> <br /><text>(or to 1..255 if force_baseline is TRUE).</text> <br /><text>CAUTION: prior to library version 6a, jpeg_add_quant_table expected</text> <br /><text>the basic table to be given in JPEG zigzag order. If you need to</text> <br /><text>write code that works with either older or newer versions of this</text> <br /><text>routine, you must check the library version number. Something like</text> <br /><text>"#if JPEG_LIB_VERSION &gt;= 61" is the right test.</text> <br /><br /><text>jpeg_simple_progression (j_compress_ptr cinfo)</text> <br /><text>Generates a default scan script for writing a progressive-JPEG file.</text> <br /><text>This is the recommended method of creating a progressive file,</text> <br /><text>unless you want to make a custom scan sequence. You must ensure that</text> <br /><text>the JPEG color space is set correctly before calling this routine.</text> <br /><br /><br /><text>Compression parameters (cinfo fields) include:</text> <br /><br /><text>J_DCT_METHOD dct_method</text> <br /><text>Selects the algorithm used for the DCT step. Choices are:</text> <br /><text>JDCT_ISLOW: slow but accurate integer algorithm</text> <br /><text>JDCT_IFAST: faster, less accurate integer method</text> <br /><text>JDCT_FLOAT: floating-point method</text> <br /><text>JDCT_DEFAULT: default method (normally JDCT_ISLOW)</text> <br /><text>JDCT_FASTEST: fastest method (normally JDCT_IFAST)</text> <br /><text>The FLOAT method is very slightly more accurate than the ISLOW method,</text> <br /><text>but may give different results on different machines due to varying</text> <br /><text>roundoff behavior. The integer methods should give the same results</text> <br /><text>on all machines. On machines with sufficiently fast FP hardware, the</text> <br /><text>floating-point method may also be the fastest. The IFAST method is</text> <br /><text>considerably less accurate than the other two; its use is not</text> <br /><text>recommended if high quality is a concern. JDCT_DEFAULT and</text> <br /><text>JDCT_FASTEST are macros configurable by each installation.</text> <br /><br /><text>J_COLOR_SPACE jpeg_color_space</text> <br /><text>int num_components</text> <br /><text>The JPEG color space and corresponding number of components; see</text> <br /><text>"Special color spaces", below, for more info. We recommend using</text> <br /><text>jpeg_set_color_space() if you want to change these.</text> <br /><br /><text>boolean optimize_coding</text> <br /><text>TRUE causes the compressor to compute optimal Huffman coding tables</text> <br /><text>for the image. This requires an extra pass over the data and</text> <br /><text>therefore costs a good deal of space and time. The default is</text> <br /><text>FALSE, which tells the compressor to use the supplied or default</text> <br /><text>Huffman tables. In most cases optimal tables save only a few percent</text> <br /><text>of file size compared to the default tables. Note that when this is</text> <br /><text>TRUE, you need not supply Huffman tables at all, and any you do</text> <br /><text>supply will be overwritten.</text> <br /><br /><text>unsigned int restart_interval</text> <br /><text>int restart_in_rows</text> <br /><text>To emit restart markers in the JPEG file, set one of these nonzero.</text> <br /><text>Set restart_interval to specify the exact interval in MCU blocks.</text> <br /><text>Set restart_in_rows to specify the interval in MCU rows. (If</text> <br /><text>restart_in_rows is not 0, then restart_interval is set after the</text> <br /><text>image width in MCUs is computed.) Defaults are zero (no restarts).</text> <br /><text>One restart marker per MCU row is often a good choice.</text> <br /><text>NOTE: the overhead of restart markers is higher in grayscale JPEG</text> <br /><text>files than in color files, and MUCH higher in progressive JPEGs.</text> <br /><text>If you use restarts, you may want to use larger intervals in those</text> <br /><text>cases.</text> <br /><br /><text>const jpeg_scan_info * scan_info</text> <br /><text>int num_scans</text> <br /><text>By default, scan_info is NULL; this causes the compressor to write a</text> <br /><text>single-scan sequential JPEG file. If not NULL, scan_info points to</text> <br /><text>an array of scan definition records of length num_scans. The</text> <br /><text>compressor will then write a JPEG file having one scan for each scan</text> <br /><text>definition record. This is used to generate noninterleaved or</text> <br /><text>progressive JPEG files. The library checks that the scan array</text> <br /><text>defines a valid JPEG scan sequence. (jpeg_simple_progression creates</text> <br /><text>a suitable scan definition array for progressive JPEG.) This is</text> <br /><text>discussed further under "Progressive JPEG support".</text> <br /><br /><text>int smoothing_factor</text> <br /><text>If non-zero, the input image is smoothed; the value should be 1 for</text> <br /><text>minimal smoothing to 100 for maximum smoothing. Consult jcsample.c</text> <br /><text>for details of the smoothing algorithm. The default is zero.</text> <br /><br /><text>boolean write_JFIF_header</text> <br /><text>If TRUE, a JFIF APP0 marker is emitted. jpeg_set_defaults() and</text> <br /><text>jpeg_set_colorspace() set this TRUE if a JFIF-legal JPEG color space</text> <br /><text>(ie, YCbCr or grayscale) is selected, otherwise FALSE.</text> <br /><br /><text>UINT8 JFIF_major_version</text> <br /><text>UINT8 JFIF_minor_version</text> <br /><text>The version number to be written into the JFIF marker.</text> <br /><text>jpeg_set_defaults() initializes the version to 1.01 (major=minor=1).</text> <br /><text>You should set it to 1.02 (major=1, minor=2) if you plan to write</text> <br /><text>any JFIF 1.02 extension markers.</text> <br /><br /><text>UINT8 density_unit</text> <br /><text>UINT16 X_density</text> <br /><text>UINT16 Y_density</text> <br /><text>The resolution information to be written into the JFIF marker;</text> <br /><text>not used otherwise. density_unit may be 0 for unknown,</text> <br /><text>1 for dots/inch, or 2 for dots/cm. The default values are 0,1,1</text> <br /><text>indicating square pixels of unknown size.</text> <br /><br /><text>boolean write_Adobe_marker</text> <br /><text>If TRUE, an Adobe APP14 marker is emitted. jpeg_set_defaults() and</text> <br /><text>jpeg_set_colorspace() set this TRUE if JPEG color space RGB, CMYK,</text> <br /><text>or YCCK is selected, otherwise FALSE. It is generally a bad idea</text> <br /><text>to set both write_JFIF_header and write_Adobe_marker. In fact,</text> <br /><text>you probably shouldn't change the default settings at all --- the</text> <br /><text>default behavior ensures that the JPEG file's color space can be</text> <br /><text>recognized by the decoder.</text> <br /><br /><text>JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS]</text> <br /><text>Pointers to coefficient quantization tables, one per table slot,</text> <br /><text>or NULL if no table is defined for a slot. Usually these should</text> <br /><text>be set via one of the above helper routines; jpeg_add_quant_table()</text> <br /><text>is general enough to define any quantization table. The other</text> <br /><text>routines will set up table slot 0 for luminance quality and table</text> <br /><text>slot 1 for chrominance.</text> <br /><br /><text>JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS]</text> <br /><text>JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS]</text> <br /><text>Pointers to Huffman coding tables, one per table slot, or NULL if</text> <br /><text>no table is defined for a slot. Slots 0 and 1 are filled with the</text> <br /><text>JPEG sample tables by jpeg_set_defaults(). If you need to allocate</text> <br /><text>more table structures, jpeg_alloc_huff_table() may be used.</text> <br /><text>Note that optimal Huffman tables can be computed for an image</text> <br /><text>by setting optimize_coding, as discussed above; there's seldom</text> <br /><text>any need to mess with providing your own Huffman tables.</text> <br /><br /><text>There are some additional cinfo fields which are not documented here</text> <br /><text>because you currently can't change them; for example, you can't set</text> <br /><text>arith_code TRUE because arithmetic coding is unsupported.</text> <br /><br /><br /><text>Per-component parameters are stored in the struct cinfo.comp_info[i] for</text> <br /><text>component number i. Note that components here refer to components of the</text> <br /><text>JPEG color space, *not* the source image color space. A suitably large</text> <br /><text>comp_info[] array is allocated by jpeg_set_defaults(); if you choose not</text> <br /><text>to use that routine, it's up to you to allocate the array.</text> <br /><br /><text>int component_id</text> <br /><text>The one-byte identifier code to be recorded in the JPEG file for</text> <br /><text>this component. For the standard color spaces, we recommend you</text> <br /><text>leave the default values alone.</text> <br /><br /><text>int h_samp_factor</text> <br /><text>int v_samp_factor</text> <br /><text>Horizontal and vertical sampling factors for the component; must</text> <br /><text>be 1..4 according to the JPEG standard. Note that larger sampling</text> <br /><text>factors indicate a higher-resolution component; many people find</text> <br /><text>this behavior quite unintuitive. The default values are 2,2 for</text> <br /><text>luminance components and 1,1 for chrominance components, except</text> <br /><text>for grayscale where 1,1 is used.</text> <br /><br /><text>int quant_tbl_no</text> <br /><text>Quantization table number for component. The default value is</text> <br /><text>0 for luminance components and 1 for chrominance components.</text> <br /><br /><text>int dc_tbl_no</text> <br /><text>int ac_tbl_no</text> <br /><text>DC and AC entropy coding table numbers. The default values are</text> <br /><text>0 for luminance components and 1 for chrominance components.</text> <br /><br /><text>int component_index</text> <br /><text>Must equal the component's index in comp_info[]. (Beginning in</text> <br /><text>release v6, the compressor library will fill this in automatically;</text> <br /><text>you don't have to.)</text> <br /></p>
    </descriptionarticle>
  </file>
</xml>