<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Progressive JPEG support</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>Progressive JPEG rearranges the stored data into a series of scans of</text> <br /><text>increasing quality. In situations where a JPEG file is transmitted across a</text> <br /><text>slow communications link, a decoder can generate a low-quality image very</text> <br /><text>quickly from the first scan, then gradually improve the displayed quality as</text> <br /><text>more scans are received. The final image after all scans are complete is</text> <br /><text>identical to that of a regular (sequential) JPEG file of the same quality</text> <br /><text>setting. Progressive JPEG files are often slightly smaller than equivalent</text> <br /><text>sequential JPEG files, but the possibility of incremental display is the main</text> <br /><text>reason for using progressive JPEG.</text> <br /><br /><text>The IJG encoder library generates progressive JPEG files when given a</text> <br /><text>suitable "scan script" defining how to divide the data into scans.</text> <br /><text>Creation of progressive JPEG files is otherwise transparent to the encoder.</text> <br /><text>Progressive JPEG files can also be read transparently by the decoder library.</text> <br /><text>If the decoding application simply uses the library as defined above, it</text> <br /><text>will receive a final decoded image without any indication that the file was</text> <br /><text>progressive. Of course, this approach does not allow incremental display.</text> <br /><text>To perform incremental display, an application needs to use the decoder</text> <br /><text>library's "buffered-image" mode, in which it receives a decoded image</text> <br /><text>multiple times.</text> <br /><br /><text>Each displayed scan requires about as much work to decode as a full JPEG</text> <br /><text>image of the same size, so the decoder must be fairly fast in relation to the</text> <br /><text>data transmission rate in order to make incremental display useful. However,</text> <br /><text>it is possible to skip displaying the image and simply add the incoming bits</text> <br /><br /><text>to the decoder's coefficient buffer. This is fast because only Huffman</text> <br /><text>decoding need be done, not IDCT, upsampling, colorspace conversion, etc.</text> <br /><text>The IJG decoder library allows the application to switch dynamically between</text> <br /><text>displaying the image and simply absorbing the incoming bits. A properly</text> <br /><text>coded application can automatically adapt the number of display passes to</text> <br /><text>suit the time available as the image is received. Also, a final</text> <br /><text>higher-quality display cycle can be performed from the buffered data after</text> <br /><text>the end of the file is reached.</text> <br /><br /><text>Progressive compression:</text> <br /><br /><text>To create a progressive JPEG file (or a multiple-scan sequential JPEG file),</text> <br /><text>set the scan_info cinfo field to point to an array of scan descriptors, and</text> <br /><text>perform compression as usual. Instead of constructing your own scan list,</text> <br /><text>you can call the jpeg_simple_progression() helper routine to create a</text> <br /><text>recommended progression sequence; this method should be used by all</text> <br /><text>applications that don't want to get involved in the nitty-gritty of</text> <br /><text>progressive scan sequence design. (If you want to provide user control of</text> <br /><text>scan sequences, you may wish to borrow the scan script reading code found</text> <br /><text>in rdswitch.c, so that you can read scan script files just like cjpeg's.)</text> <br /><text>When scan_info is not NULL, the compression library will store DCT'd data</text> <br /><text>into a buffer array as jpeg_write_scanlines() is called, and will emit all</text> <br /><text>the requested scans during jpeg_finish_compress(). This implies that</text> <br /><text>multiple-scan output cannot be created with a suspending data destination</text> <br /><text>manager, since jpeg_finish_compress() does not support suspension. We</text> <br /><text>should also note that the compressor currently forces Huffman optimization</text> <br /><text>mode when creating a progressive JPEG file, because the default Huffman</text> <br /><text>tables are unsuitable for progressive files.</text> <br /><br /><text>Progressive decompression:</text> <br /><br /><text>When buffered-image mode is not used, the decoder library will read all of</text> <br /><text>a multi-scan file during jpeg_start_decompress(), so that it can provide a</text> <br /><text>final decoded image. (Here "multi-scan" means either progressive or</text> <br /><text>multi-scan sequential.) This makes multi-scan files transparent to the</text> <br /><text>decoding application. However, existing applications that used suspending</text> <br /><text>input with version 5 of the IJG library will need to be modified to check</text> <br /><text>for a suspension return from jpeg_start_decompress().</text> <br /><br /><text>To perform incremental display, an application must use the library's</text> <br /><text>buffered-image mode. This is described in the next section.</text> <br /></descriptionarticle>
  </file>
</xml>