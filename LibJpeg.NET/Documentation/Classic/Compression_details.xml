<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Compression details</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <text>Here we revisit the JPEG compression outline given in the </text> <link file="Outline_of_typical_usage.xml"><text>overview</text> </link><text>.</text> <br /><br /><b><text>1.</text> </b><text> Allocate and initialize a JPEG compression object.</text> <br /><br /><text>A JPEG compression object is a "class </text> <link file="../jpeg_compress_struct.xml"><text>jpeg_compress_struct</text> </link><text>". You will also need a structure representing a JPEG error handler. The part of this that the library cares about is a "class </text> <link file="../jpeg_error_mgr.xml"><text>jpeg_error_mgr</text> </link><text>". If you are providing your own error handler, you'll typically want to embed the</text> <br /><text>jpeg_error_mgr struct in a larger structure; this is discussed later under "</text> <link file="Error_handling.xml"><text>Error handling</text> </link><text>". For now we'll assume you are just using the default error handler. The default error handler will print JPEG error/warning messages on console, and it will throw an exception if a fatal error occurs.</text> <br /><br /><text>Typical code for this step, if you are using the default error handler, is</text> <br /><br /><i><text>jpeg_error_mgr errorManager = new jpeg_error_mgr();</text> </i></p>
      <p>
        <i>
          <text>jpeg_compress_struct cinfo = new jpeg_compress_struct(errorManager);</text> <br /><text>or</text> <br /><text>jpeg_compress_struct cinfo = new jpeg_compress_struct();</text> <br /><text>cinfo.Err = </text> </i>
        <i>
          <text>errorManager;</text> </i>
      </p>
      <p>
        <b>
          <text>2.</text> </b>
        <text> Specify the destination for the compressed data (e.g., a file)</text> <br /><br /><text>As previously mentioned, the JPEG library delivers compressed data to a "data destination" module. The library includes one data destination module which knows how to write to a System.IO.Stream. You can use your own destination module if you want to do something else, as discussed later.</text> <br /><br /><text>If you use the standard destination module, you must open the target System.IO.Stream beforehand. Typical code for this step looks like:</text> </p>
      <p>
        <i>
          <text>Stream output = ...; //initializing of stream for subsequent writing</text> <br /><text>cinfo.jpeg_stdio_dest(output);</text> </i>
        <br />
        <br />
        <text>where the last line invokes the standard destination module.</text> <br /><br /><text>You can select the data destination after setting other parameters (step 3), if that's more convenient. You may not change the destination between calling </text> <link file="../jpeg_compress_struct.jpeg_start_compress.xml"><text>jpeg_start_compress</text> </link><text>() and </text> <link file="../jpeg_compress_struct.jpeg_finish_compress.xml"><text>jpeg_finish_compress</text> </link><text>().</text> <br /><br /><b><text>3.</text> </b><text> Set parameters for compression, including image size and colorspace.</text> <br /><br /><text>You must supply information about the source image by setting the following properties in the JPEG object (</text> <link file="../jpeg_compress_struct.xml"><text>jpeg_compress_struct</text> </link><text>):</text> </p>
      <p>
        <table>
          <tbody>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.Image_width.xml">
                  <text>Image_width</text> </link>
              </td>
              <td>
                <text>Width of image, in pixels</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.Image_height.xml">
                  <text>Image_height</text> </link>
              </td>
              <td>
                <text>Height of image, in pixels</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.Input_components.xml">
                  <text>Input_components</text> </link>
              </td>
              <td>
                <text>Number of color channels (components per pixel)</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_compress_struct.In_color_space.xml">
                  <text>In_color_space</text> </link>
              </td>
              <td>
                <text>Color space of source image</text> </td>
            </tr>
          </tbody>
        </table>
      </p>
      <p>
        <br />
        <text>The image dimensions are, hopefully, obvious. JPEG supports image dimensions of 1 to 64K pixels in either direction. The input color space is typically RGB or grayscale, and input_components is 3 or 1 accordingly. (See "</text> <link file="Special_color_spaces.xml"><text>Special color spaces</text> </link><text>" for more info) The </text> <link file="../jpeg_compress_struct.In_color_space.xml"><text>In_color_space</text> </link><text> property must be</text> <br /><text>assigned one of the </text> <link file="../J_COLOR_SPACE.xml"><text>J_COLOR_SPACE</text> </link><text> enum constants, typically JCS_RGB or JCS_GRAYSCALE.</text> <br /><br /><text>JPEG has a large number of compression parameters that determine how the image is encoded. Most applications don't need or want to know about all these parameters. You can set all the parameters to reasonable defaults by calling </text> <link file="../jpeg_compress_struct.jpeg_set_defaults.xml"><text>jpeg_set_defaults</text> </link><text>(); then, if there are particular values you want</text> <br /><text>to change, you can do so after that. The "</text> <link file="Compression_parameter_selection.xml"><text>Compression parameter selection</text> </link><text>" section tells about all the parameters.</text> <br /><br /><text>You must set </text> <link file="../jpeg_compress_struct.In_color_space.xml"><text>In_color_space</text> </link><text> correctly before calling </text> <link file="../jpeg_compress_struct.jpeg_set_defaults.xml"><text>jpeg_set_defaults</text> </link><text>(), because the defaults depend on the source image colorspace. However the other three source image parameters need not be valid until you call </text> <link file="../jpeg_compress_struct.jpeg_start_compress.xml"><text>jpeg_start_compress</text> </link><text>(). There's no harm in calling </text> <link file="../jpeg_compress_struct.jpeg_set_defaults.xml"><text>jpeg_set_defaults</text> </link><text>() more than once, if that happens to be convenient.</text> <br /><br /><text>Typical code for a 24-bit RGB source image is</text> <br /><br /><i><text>cinfo.Image_width = Width; /* image width and height, in pixels */</text> <br /><text>cinfo.Image_height = Height;</text> <br /><text>cinfo.Input_components = 3; /* Number of color components per pixel */</text> <br /><text>cinfo.In_color_space = JCS_RGB; /* colorspace of input image */</text> </i><br /><br /><i><text>cinfo.jpeg_set_defaults();</text> </i><br /><text>/* Make optional parameter settings here */</text> <br /><br /><b><text>4.  </text> </b><link file="../jpeg_compress_struct.jpeg_start_compress.xml"><i><text>jpeg_start_compress</text> </i></link><i><text>(...);</text> <br /></i><br /><text>After you have established the data destination and set all the necessary source image info and other parameters, call jpeg_start_compress() to begin a compression cycle. This will initialize internal state, allocate working storage, and emit the first few bytes of the JPEG datastream header.</text> <br /><br /><text>Typical code:</text> <br /><br /><i><text>cinfo.jpeg_start_compress(true);</text> </i><br /><br /><text>The "true" parameter ensures that a complete JPEG interchange datastream will be written. This is appropriate in most cases. If you think you might want to use an abbreviated datastream, read the section on abbreviated datastreams, below.</text> <br /><br /><text>Once you have called jpeg_start_compress(), you may not alter any JPEG parameters or other fields of the JPEG object until you have completed the compression cycle.</text> <br /><br /><b><text>5.</text> </b><i><text>while (scan lines remain to be written)</text> <br /><text>        </text> </i><link file="../jpeg_compress_struct.jpeg_write_scanlines.xml"><i><text>jpeg_write_scanlines</text> </i></link><i><text>(...);</text> </i><br /><br /><text>Now write all the required image data by calling jpeg_write_scanlines() one or more times. You can pass one or more scanlines in each call, up to the total image height. In most applications it is convenient to pass just one or a few scanlines at a time. The expected format for the passed</text> <br /><text>data is discussed under "</text> <link file="Data_formats.xml"><text>Data formats</text> </link><text>", above.</text> <br /><br /><text>Image data should be written in top-to-bottom scanline order. The JPEG spec contains some weasel wording about how top and bottom are application-defined terms (a curious interpretation of the English language...) but if you want your files to be compatible with everyone else's, you WILL use top-to-bottom order. If the source data must be read in bottom-to-top order, you can use the JPEG library's virtual array mechanism to invert the data efficiently.</text> <br /><text>Examples of this can be found in the sample application cJpeg.</text> <br /><br /><text>The library maintains a count of the number of scanlines written so far in the </text> <link file="../jpeg_compress_struct.Next_scanline.xml"><text>Next_scanline</text> </link><text> property of the JPEG object. Usually you can just use this variable as the loop counter, so that the loop test looks like "</text> <i><text>while (cinfo.Next_scanline &lt; cinfo.Image_height)</text> </i><text>"</text> <br /><br /><text>Code for this step depends heavily on the way that you store the source data. Here is the example for the case of a full-size 2-D source array containing 3-byte RGB pixels (</text> <i><text>byte[][] image_buffer</text> </i><text>):</text> <br /><br /><i><text>byte[][] rowData = new byte[1][]; /* pointer to a single row */</text> </i><br /><i><text>int row_stride = cinfo.Image_width * 3; /* physical row width in buffer */</text> <br /><br /><text>while (cinfo.Next_scanline &lt; cinfo.Image_height)</text> <br /><text>{</text> <br /><text>    rowData[0] = image_buffer[cinfo.Next_scanline];</text> <br /><text>    cinfo.jpeg_write_scanlines(rowData, 1);</text> <br /><text>}</text> </i></p>
      <p>
        <link file="../jpeg_compress_struct.jpeg_write_scanlines.xml">
          <text>jpeg_write_scanlines</text> </link>
        <text>() returns the number of scanlines actually written. This will normally be equal to the number passed in, so you can usually ignore the return value. It is different if you try to write more scanlines than the declared image height, the additional scanlines are ignored.</text> <br /><br /><b><text>6. </text> </b><link file="../jpeg_compress_struct.jpeg_finish_compress.xml"><i><text>jpeg_finish_compress</text> </i></link><i><text>(...);</text> <br /></i><br /><text>After all the image data has been written, call jpeg_finish_compress() to complete the compression cycle. This step is ESSENTIAL to ensure that the last bufferload of data is written to the data destination.</text> <br /><br /><text>jpeg_finish_compress() also releases working memory associated with the JPEG object.</text> <br /><br /><text>Typical code:</text> <br /><br /><i><text>cinfo.jpeg_finish_compress();</text> </i><br /><br /><text>If using the standard destination manager, don't forget to close the output stream (if necessary) afterwards.</text> <br /><br /><text>If you have requested a multi-pass operating mode, such as Huffman code optimization, jpeg_finish_compress() will perform the additional passes using data buffered by the first pass. In this case jpeg_finish_compress() may take quite a while to complete. With the default compression parameters, this will not happen.</text> <br /><br /><text>It is an error to call </text> <link file="../jpeg_compress_struct.jpeg_finish_compress.xml"><text>jpeg_finish_compress</text> </link><text>() before writing the necessary total number of scanlines. If you wish to abort compression, call </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>() as discussed below.</text> <br /><br /><text>After completing a compression cycle you may use it to compress another image. In that case return to step 2, 3, or 4 as appropriate. If you do not change the destination manager, the new datastream will be written to the same target.</text> <br /><text>If you do not change any JPEG parameters, the new datastream will be written with the same parameters as before. Note that you can change the input image dimensions freely between cycles, but if you change the input colorspace, you should call </text> <link file="../jpeg_compress_struct.jpeg_set_defaults.xml"><text>jpeg_set_defaults</text> </link><text>() to adjust for the new colorspace; and then you'll need to repeat all of step 3.</text> <br /><br /><b><text>7.</text> </b><text> Aborting.</text> <br /><br /><text>If you decide to abort a compression cycle before finishing, you can call </text> <link file="../jpeg_compress_struct.jpeg_abort_compress.xml"><text>jpeg_abort_compress</text> </link><text>(), or call </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>() which works on both compression and decompression objects. This will return the object to an idle state, releasing any working memory. jpeg_abort() is allowed at any time after successful object creation.</text> </p>
      <p>
        <text>jpeg_abort() is the only safe calls to make on a JPEG object that has reported an error by calling </text> <link file="../jpeg_error_mgr.error_exit.xml"><text>error_exit</text> </link><text> (see "</text> <link file="Error_handling.xml"><text>Error handling</text> </link><text>" for more info). The internal state of such an object is likely to be out of whack. Either of these two routines will return the object to a known state.</text> </p>
    </descriptionarticle>
    <seealso>
      <ref caption="Outline of typical usage" file="Outline_of_typical_usage.xml" />
      <ref caption="Decompression details" file="Decompression_details.xml" />
    </seealso>
  </file>
</xml>