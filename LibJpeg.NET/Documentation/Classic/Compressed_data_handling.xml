<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Compressed data handling</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>The JPEG compression library sends its compressed data to a "</text> <link file="../jpeg_destination_mgr.xml"><text>destination manager</text> </link><text>" module. The default destination manager just writes the data to a Stream, but you can provide your own manager to do something else. Similarly, the decompression library calls a "</text> <link file="../jpeg_source_mgr.xml"><text>source manager</text> </link><text>" to obtain the compressed data; you can provide your own source manager if you want the data to come from somewhere other than a Stream.</text> <br /><br /><text>In both cases, compressed data is processed a bufferload at a time: the destination or source manager provides a work buffer, and the library invokes the manager only when the buffer is filled or emptied. (You could define a one-character buffer to force the manager to be invoked for each byte, but that would be rather inefficient.) The buffer's size and location are controlled by the manager, not by the library. For example, if you desired to decompress a JPEG datastream that was all in memory, you could just make the buffer pointer and length point to the original data in memory. Then the buffer-reload procedure would be invoked only if the decompressor ran off the end of the datastream, which would indicate an erroneous datastream.</text> <br /><br /><text>The work buffer is defined as an array of datatype JOCTET, which is generally "char" or "unsigned char". On a machine where char is not exactly 8 bits wide, you must define JOCTET as a wider data type and then modify the data source and destination modules to transcribe the work arrays into 8-bit units on external storage.</text> <br /><br /><text>A data destination manager struct contains a pointer and count defining the next byte to write in the work buffer and the remaining free space:</text> <br /><br /><text>JOCTET * next_output_byte; /* =&gt; next byte to write in buffer */</text> <br /><text>size_t free_in_buffer; /* # of byte spaces remaining in buffer */</text> <br /><br /><text>The library increments the pointer and decrements the count until the buffer is filled. The manager's empty_output_buffer method must reset the pointer and count. The manager is expected to remember the buffer's starting address and total size in private fields not visible to the library.</text> <br /><br /><text>A data destination manager provides three </text> <b><text>methods</text> </b><text>:</text> <br /><br /><table><tbody><tr><td><text>init_destination</text> </td><td><text>Initialize destination. This is called by jpeg_start_compress() before any data is actually written. It must initialize next_output_byte and free_in_buffer. free_in_buffer must be initialized to a positive value.</text> </td></tr><tr><td><text>empty_output_buffer</text> </td><td><text>This is called whenever the buffer has filled (free_in_buffer reaches zero). In typical applications, it should write out the *entire* buffer (use the saved start address and buffer length; ignore the current state of next_output_byte and free_in_buffer).</text> <br /><text>Then reset the pointer &amp; count to the start of the buffer, and return TRUE indicating that the buffer has been dumped.</text> <br /><text>free_in_buffer must be set to a positive value when TRUE is returned. A FALSE return should only be used when I/O suspension is desired (this operating mode is discussed in the next section).</text> </td></tr><tr><td><text>term_destination</text> </td><td><text>Terminate destination --- called by jpeg_finish_compress() after all data has been written. In most applications, this must flush any data remaining in the buffer. Use either next_output_byte or free_in_buffer to determine how much data is in the buffer.</text> <br /><br /><text>term_destination() is NOT called by jpeg_abort() or jpeg_destroy(). If you want the destination manager to be cleaned up during an abort, you must do it yourself.</text> <br /></td></tr></tbody></table><text> </text> <br /><text>You will also need code to create a jpeg_destination_mgr struct, fill in its method pointers, and insert a pointer to the struct into the "dest" field of the JPEG compression object. This can be done in-line in your setup code if you like, but it's probably cleaner to provide a separate routine similar to the jpeg_stdio_dest() routine of the supplied destination manager.</text> <br /><br /><text>Decompression source managers follow a parallel design, but with some additional frammishes. The source manager struct contains a pointer and count defining the next byte to read from the work buffer and the number of bytes remaining:</text> <br /><br /><text>const JOCTET * next_input_byte; /* =&gt; next byte to read from buffer */</text> <br /><text>size_t bytes_in_buffer; /* # of bytes remaining in buffer */</text> <br /><br /><text>The library increments the pointer and decrements the count until the buffer is emptied. The manager's fill_input_buffer method must reset the pointer and count. In most applications, the manager must remember the buffer's starting address and total size in private fields not visible to the library.</text> <br /><br /><text>A data source manager provides five methods:</text> <br /><br /><table><tbody><tr><td><text>init_source</text> </td><td><text>Initialize source. This is called by jpeg_read_header() before any data is actually read. Unlike init_destination(), it may leave bytes_in_buffer set to 0 (in which case a fill_input_buffer() call will occur immediately).</text> </td></tr><tr><td><text>fill_input_buffer</text> </td><td><text>This is called whenever bytes_in_buffer has reached zero and more data is wanted. In typical applications, it should read fresh data into the buffer (ignoring the current state of next_input_byte and bytes_in_buffer), reset the pointer &amp; count to the start of the buffer, and return TRUE indicating that the buffer has been reloaded.</text> <br /><text>It is not necessary to fill the buffer entirely, only to obtain at least one more byte. bytes_in_buffer MUST be set to a positive value if TRUE is returned. A FALSE return should only be used when I/O suspension is desired (this mode is discussed in the next section).</text> </td></tr><tr><td><text>skip_input_data (long num_bytes)</text> </td><td><text>Skip num_bytes worth of data. The buffer pointer and count should be advanced over num_bytes input bytes, refilling the buffer as needed. This is used to skip over a potentially large amount of uninteresting data (such as an APPn marker). In some applications it may be possible to optimize away the reading of the skipped data,</text> <br /><text>but it's not clear that being smart is worth much trouble; large skips are uncommon. bytes_in_buffer may be zero on return.</text> <br /><text>A zero or negative skip count should be treated as a no-op.</text> </td></tr><tr><td><text>resync_to_restart (int desired)</text> </td><td><text>This routine is called only when the decompressor has failed to find a restart (RSTn) marker where one is expected. Its mission is to find a suitable point for resuming decompression. For most applications, we recommend that you just use the default resync procedure, jpeg_resync_to_restart(). However, if you are able to back up in the input data stream, or if you have a-priori knowledge about the likely location of restart markers, you may be able to do better.</text> <br /><text>Read the read_restart_marker() and jpeg_resync_to_restart() routines in jdmarker.c if you think you'd like to implement your own resync procedure.</text> </td></tr><tr><td><text>term_source</text> </td><td><p><text>Terminate source - called by jpeg_finish_decompress() after all data has been read. Often a no-op.</text> </p><p><text>term_source() is NOT called by jpeg_abort() or jpeg_destroy(). If you want the source manager to be cleaned up during an abort, you must do it yourself.</text> </p></td></tr></tbody></table><br /><text>For both fill_input_buffer() and skip_input_data(), there is no such thing as an EOF return. If the end of the file has been reached, the routine has a choice of exiting via ERREXIT() or inserting fake data into the buffer.</text> <br /><text>In most cases, generating a warning message and inserting a fake EOI marker is the best course of action --- this will allow the decompressor to output however much of the image is there. In pathological cases, the decompressor may swallow the EOI and again demand data ... just keep feeding it fake EOIs.</text> <br /><text>jdatasrc.c illustrates the recommended error recovery behavior.</text> <br /><br /><text>You will also need code to create a jpeg_source_mgr struct, fill in its method pointers, and insert a pointer to the struct into the "src" field of the JPEG decompression object. This can be done in-line in your setup code if you like, but it's probably cleaner to provide a separate routine similar to the jpeg_stdio_src() routine of the supplied source manager.</text> </descriptionarticle>
  </file>
</xml>