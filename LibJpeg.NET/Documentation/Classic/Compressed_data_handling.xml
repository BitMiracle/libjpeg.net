<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Compressed data handling</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <text>The decompression library calls a "</text> <link file="../jpeg_source_mgr.xml"><text>source manager</text> </link><text>" to obtain the compressed data; you can provide your own source manager if you want the data to come from somewhere other than a Stream.</text> <br /><br /><text>Decompression source managers follow a parallel design, but with some additional frammishes. The source manager struct contains a pointer and count defining the next byte to read from the work buffer and the number of bytes remaining:</text> <br /><br /><text>private const byte[] next_input_byte; /* =&gt; next byte to read from buffer */</text> <br /><text>private int bytes_in_buffer; /* # of bytes remaining in buffer */</text> <br /><br /><text>The library increments the pointer and decrements the count until the buffer is emptied. The manager's fill_input_buffer method must reset the pointer and count. In most applications, the manager must remember the buffer's starting address and total size in private fields not visible to the library.</text> <br /><br /><text>A data source manager provides five methods:</text> <br /><br /></p>
      <table>
        <tbody>
          <tr>
            <td>
              <text>init_source</text> </td>
            <td>
              <text>Initialize source. This is called by jpeg_read_header() before any data is actually read. Unlike init_destination(), it may leave bytes_in_buffer set to 0 (in which case a fill_input_buffer() call will occur immediately).</text> </td>
          </tr>
          <tr>
            <td>
              <text>fill_input_buffer</text> </td>
            <td>
              <text>This is called whenever bytes_in_buffer has reached zero and more data is wanted. In typical applications, it should read fresh data into the buffer (ignoring the current state of next_input_byte and bytes_in_buffer), reset the pointer &amp; count to the start of the buffer, and return TRUE indicating that the buffer has been reloaded.</text> <br /><text>It is not necessary to fill the buffer entirely, only to obtain at least one more byte. bytes_in_buffer MUST be set to a positive value if TRUE is returned. A FALSE return should only be used when I/O suspension is desired (this mode is discussed in the next section).</text> </td>
          </tr>
          <tr>
            <td>
              <text>skip_input_data (long num_bytes)</text> </td>
            <td>
              <text>Skip num_bytes worth of data. The buffer pointer and count should be advanced over num_bytes input bytes, refilling the buffer as needed. This is used to skip over a potentially large amount of uninteresting data (such as an APPn marker). In some applications it may be possible to optimize away the reading of the skipped data,</text> <br /><text>but it's not clear that being smart is worth much trouble; large skips are uncommon. bytes_in_buffer may be zero on return.</text> <br /><text>A zero or negative skip count should be treated as a no-op.</text> </td>
          </tr>
          <tr>
            <td>
              <text>resync_to_restart (int desired)</text> </td>
            <td>
              <text>This routine is called only when the decompressor has failed to find a restart (RSTn) marker where one is expected. Its mission is to find a suitable point for resuming decompression. For most applications, we recommend that you just use the default resync procedure, jpeg_resync_to_restart(). However, if you are able to back up in the input data stream, or if you have a-priori knowledge about the likely location of restart markers, you may be able to do better.</text> <br /><text>Read the read_restart_marker() and jpeg_resync_to_restart() routines in jdmarker.c if you think you'd like to implement your own resync procedure.</text> </td>
          </tr>
          <tr>
            <td>
              <text>term_source</text> </td>
            <td>
              <p>
                <text>Terminate source - called by jpeg_finish_decompress() after all data has been read. Often a no-op.</text> </p>
              <p>
                <text>term_source() is NOT called by jpeg_abort() or jpeg_destroy(). If you want the source manager to be cleaned up during an abort, you must do it yourself.</text> </p>
            </td>
          </tr>
        </tbody>
      </table>
      <br />
      <text>For both fill_input_buffer() and skip_input_data(), there is no such thing as an EOF return. If the end of the file has been reached, the routine has a choice of exiting via ERREXIT() or inserting fake data into the buffer.</text> <br /><text>In most cases, generating a warning message and inserting a fake EOI marker is the best course of action --- this will allow the decompressor to output however much of the image is there. In pathological cases, the decompressor may swallow the EOI and again demand data ... just keep feeding it fake EOIs.</text> <br /><br /><text>You will also need code to create a jpeg_source_mgr struct, fill in its method pointers, and insert a pointer to the struct into the "src" field of the JPEG decompression object. This can be done in-line in your setup code if you like, but it's probably cleaner to provide a separate routine similar to the jpeg_stdio_src() routine of the supplied source manager.</text> </descriptionarticle>
  </file>
</xml>