<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Outline of typical usage</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <b>
          <text>1.</text> </b>
        <text> The rough outline of a </text> <b><text>JPEG compression</text> </b><text> operation is:</text> <br /><br /><text>Allocate and initialize a JPEG compression object</text> <br /><text>Specify the destination for the compressed data (e.g., a file)</text> <br /><br /><i><text>Set parameters for compression, including image size and colorspace</text> <br /></i><link file="../jpeg_compress_struct.jpeg_start_compress.xml"><i><text>jpeg_start_compress</text> </i></link><i><text>(...);</text> <br /><text>while (scan lines remain to be written)</text> <br /><text>    </text> </i><link file="../jpeg_compress_struct.jpeg_write_scanlines.xml"><i><text>jpeg_write_scanlines</text> </i></link><i><text>(...);</text> <br /></i><link file="../jpeg_compress_struct.jpeg_finish_compress.xml"><i><text>jpeg_finish_compress</text> </i></link><i><text>(...);</text> </i><br /><br /><text>A JPEG compression object holds parameters and working state for the JPEG library. We make creation/destruction of the object separate from starting or finishing compression of an image; the same object can be re-used for a series of image compression operations. This makes it easy to re-use the same parameter settings for a sequence of images. Re-use of a JPEG object also has important implications for processing abbreviated JPEG datastreams, as discussed later.</text> <br /><br /><text>The image data to be compressed is supplied to </text> <link file="../jpeg_compress_struct.jpeg_write_scanlines.xml"><text>jpeg_write_scanlines</text> </link><text>() from in-memory buffers. If the application is doing file-to-file compression, reading image data from the source file is the application's responsibility.</text> <br /><text>The library emits compressed data by calling a "data destination manager", which typically will write the data into a file; but the application can provide its own destination manager to do something else.</text> </p>
      <p>
        <text>For further information see the article "</text> <link file="Compression_details.xml"><text>Compression details</text> </link><text>"</text> </p>
      <p>
        <br />
        <b>
          <text>2.</text> </b>
        <text> Similarly, the rough outline of a </text> <b><text>JPEG decompression</text> </b><text> operation is:</text> <br /><br /><i><text>Allocate and initialize a JPEG decompression object</text> <br /><text>Specify the source of the compressed data (eg, a file)</text> <br /><text>Call </text> </i><link file="../jpeg_decompress_struct.jpeg_read_header.xml"><i><text>jpeg_read_header</text> </i></link><i><text>() to obtain image info</text> <br /><text>Set parameters for decompression</text> <br /></i><link file="../jpeg_decompress_struct.jpeg_start_decompress.xml"><i><text>jpeg_start_decompress</text> </i></link><i><text>(...);</text> <br /><text>while (scan lines remain to be read)</text> <br /><text>    </text> </i><link file="../jpeg_decompress_struct.jpeg_read_scanlines.xml"><i><text>jpeg_read_scanlines</text> </i></link><i><text>(...);</text> <br /></i><link file="../jpeg_decompress_struct.jpeg_finish_decompress.xml"><i><text>jpeg_finish_decompress</text> </i></link><i><text>(...);</text> </i><br /><br /><text>This is comparable to the compression outline except that reading the datastream header is a separate step. This is helpful because information about the image's size, colorspace, etc is available when the application selects decompression parameters. For example, the application can choose an output scaling ratio that will fit the image into the available screen size.</text> <br /><br /><text>The decompression library obtains compressed data by calling a data source manager, which typically will read the data from a file; but other behaviors can be obtained with a custom source manager. Decompressed data is delivered into in-memory buffers passed to </text> <link file="../jpeg_decompress_struct.jpeg_read_scanlines.xml"><text>jpeg_read_scanlines</text> </link><text>()</text> <br /><br /><text>It is possible to abort an incomplete compression or decompression operation by calling </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>(); or, if you do not need to retain the JPEG object, simply release it by calling </text> <link file="../jpeg_common_struct.jpeg_destroy.xml"><text>jpeg_destroy</text> </link><text>()</text> <br /><br /><text>JPEG compression and decompression objects are two separate struct types. However, they share some common fields, and certain routines such as </text> <link file="../jpeg_common_struct.jpeg_destroy.xml"><text>jpeg_destroy</text> </link><text>() can work on either type of object.</text> <br /><br /><text>The JPEG library has no static variables: all state is in the compression or decompression object. Therefore it is possible to process multiple compression and decompression operations concurrently, using multiple JPEG objects.</text> </p>
      <p>
        <text>For further information see the article "</text> <link file="Decompression_details.xml"><text>Decompression details</text> </link><text>"</text> </p>
      <p>
        <br />
        <text>Both compression and decompression can be done in an incremental memory-to-memory fashion, if suitable source/destination managers are used. See the section on "</text> <link file="I_O_suspension.xml"><text>I/O suspension</text> </link><text>" for more details.</text> </p>
    </descriptionarticle>
    <seealso>
      <ref caption="Compression details" file="Compression_details.xml" />
      <ref caption="Decompression details" file="Decompression_details.xml" />
    </seealso>
  </file>
</xml>