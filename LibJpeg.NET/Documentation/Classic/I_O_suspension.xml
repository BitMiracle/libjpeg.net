<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>I/O suspension</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>Some applications need to use the JPEG library as an incremental memory-to-</text> <br /><text>memory filter: when the compressed data buffer is filled or emptied, they want</text> <br /><text>control to return to the outer loop, rather than expecting that the buffer can</text> <br /><text>be emptied or reloaded within the data source/destination manager subroutine.</text> <br /><text>The library supports this need by providing an "I/O suspension" mode, which we</text> <br /><text>describe in this section.</text> <br /><br /><text>The I/O suspension mode is not a panacea: nothing is guaranteed about the</text> <br /><text>maximum amount of time spent in any one call to the library, so it will not</text> <br /><text>eliminate response-time problems in single-threaded applications. If you</text> <br /><text>need guaranteed response time, we suggest you "bite the bullet" and implement</text> <br /><text>a real multi-tasking capability.</text> <br /><br /><text>To use I/O suspension, cooperation is needed between the calling application</text> <br /><text>and the data source or destination manager; you will always need a custom</text> <br /><text>source/destination manager. (Please read the previous section if you haven't</text> <br /><text>already.) The basic idea is that the empty_output_buffer() or</text> <br /><text>fill_input_buffer() routine is a no-op, merely returning FALSE to indicate</text> <br /><text>that it has done nothing. Upon seeing this, the JPEG library suspends</text> <br /><text>operation and returns to its caller. The surrounding application is</text> <br /><text>responsible for emptying or refilling the work buffer before calling the</text> <br /><text>JPEG library again.</text> <br /><br /><text>Compression suspension:</text> <br /><br /><text>For compression suspension, use an empty_output_buffer() routine that returns</text> <br /><text>FALSE; typically it will not do anything else. This will cause the</text> <br /><text>compressor to return to the caller of jpeg_write_scanlines(), with the return</text> <br /><text>value indicating that not all the supplied scanlines have been accepted.</text> <br /><text>The application must make more room in the output buffer, adjust the output</text> <br /><text>buffer pointer/count appropriately, and then call jpeg_write_scanlines()</text> <br /><text>again, pointing to the first unconsumed scanline.</text> <br /><br /><text>When forced to suspend, the compressor will backtrack to a convenient stopping</text> <br /><text>point (usually the start of the current MCU); it will regenerate some output</text> <br /><text>data when restarted. Therefore, although empty_output_buffer() is only</text> <br /><text>called when the buffer is filled, you should NOT write out the entire buffer</text> <br /><text>after a suspension. Write only the data up to the current position of</text> <br /><text>next_output_byte/free_in_buffer. The data beyond that point will be</text> <br /><text>regenerated after resumption.</text> <br /><br /><text>Because of the backtracking behavior, a good-size output buffer is essential</text> <br /><text>for efficiency; you don't want the compressor to suspend often. (In fact, an</text> <br /><text>overly small buffer could lead to infinite looping, if a single MCU required</text> <br /><text>more data than would fit in the buffer.) We recommend a buffer of at least</text> <br /><text>several Kbytes. You may want to insert explicit code to ensure that you don't</text> <br /><text>call jpeg_write_scanlines() unless there is a reasonable amount of space in</text> <br /><text>the output buffer; in other words, flush the buffer before trying to compress</text> <br /><text>more data.</text> <br /><br /><text>The compressor does not allow suspension while it is trying to write JPEG</text> <br /><text>markers at the beginning and end of the file. This means that:</text> <br /><text>* At the beginning of a compression operation, there must be enough free</text> <br /><text>space in the output buffer to hold the header markers (typically 600 or</text> <br /><text>so bytes). The recommended buffer size is bigger than this anyway, so</text> <br /><text>this is not a problem as long as you start with an empty buffer. However,</text> <br /><text>this restriction might catch you if you insert large special markers, such</text> <br /><text>as a JFIF thumbnail image, without flushing the buffer afterwards.</text> <br /><text>* When you call jpeg_finish_compress(), there must be enough space in the</text> <br /><text>output buffer to emit any buffered data and the final EOI marker. In the</text> <br /><text>current implementation, half a dozen bytes should suffice for this, but</text> <br /><text>for safety's sake we recommend ensuring that at least 100 bytes are free</text> <br /><text>before calling jpeg_finish_compress().</text> <br /><br /><text>A more significant restriction is that jpeg_finish_compress() cannot suspend.</text> <br /><text>This means you cannot use suspension with multi-pass operating modes, namely</text> <br /><text>Huffman code optimization and multiple-scan output. Those modes write the</text> <br /><text>whole file during jpeg_finish_compress(), which will certainly result in</text> <br /><text>buffer overrun. (Note that this restriction applies only to compression,</text> <br /><text>not decompression. The decompressor supports input suspension in all of its</text> <br /><text>operating modes.)</text> <br /><br /><text>Decompression suspension:</text> <br /><br /><text>For decompression suspension, use a fill_input_buffer() routine that simply</text> <br /><text>returns FALSE (except perhaps during error recovery, as discussed below).</text> <br /><text>This will cause the decompressor to return to its caller with an indication</text> <br /><text>that suspension has occurred. This can happen at four places:</text> <br /><text>* jpeg_read_header(): will return JPEG_SUSPENDED.</text> <br /><text>* jpeg_start_decompress(): will return FALSE, rather than its usual TRUE.</text> <br /><text>* jpeg_read_scanlines(): will return the number of scanlines already</text> <br /><text>completed (possibly 0).</text> <br /><text>* jpeg_finish_decompress(): will return FALSE, rather than its usual TRUE.</text> <br /><text>The surrounding application must recognize these cases, load more data into</text> <br /><text>the input buffer, and repeat the call. In the case of jpeg_read_scanlines(),</text> <br /><text>increment the passed pointers past any scanlines successfully read.</text> <br /><br /><text>Just as with compression, the decompressor will typically backtrack to a</text> <br /><text>convenient restart point before suspending. When fill_input_buffer() is</text> <br /><text>called, next_input_byte/bytes_in_buffer point to the current restart point,</text> <br /><text>which is where the decompressor will backtrack to if FALSE is returned.</text> <br /><text>The data beyond that position must NOT be discarded if you suspend; it needs</text> <br /><text>to be re-read upon resumption. In most implementations, you'll need to shift</text> <br /><text>this data down to the start of your work buffer and then load more data after</text> <br /><text>it. Again, this behavior means that a several-Kbyte work buffer is essential</text> <br /><text>for decent performance; furthermore, you should load a reasonable amount of</text> <br /><text>new data before resuming decompression. (If you loaded, say, only one new</text> <br /><text>byte each time around, you could waste a LOT of cycles.)</text> <br /><br /><text>The skip_input_data() source manager routine requires special care in a</text> <br /><text>suspension scenario. This routine is NOT granted the ability to suspend the</text> <br /><text>decompressor; it can decrement bytes_in_buffer to zero, but no more. If the</text> <br /><text>requested skip distance exceeds the amount of data currently in the input</text> <br /><text>buffer, then skip_input_data() must set bytes_in_buffer to zero and record the</text> <br /><text>additional skip distance somewhere else. The decompressor will immediately</text> <br /><text>call fill_input_buffer(), which should return FALSE, which will cause a</text> <br /><text>suspension return. The surrounding application must then arrange to discard</text> <br /><text>the recorded number of bytes before it resumes loading the input buffer.</text> <br /><text>(Yes, this design is rather baroque, but it avoids complexity in the far more</text> <br /><text>common case where a non-suspending source manager is used.)</text> <br /><br /><text>If the input data has been exhausted, we recommend that you emit a warning</text> <br /><text>and insert dummy EOI markers just as a non-suspending data source manager</text> <br /><text>would do. This can be handled either in the surrounding application logic or</text> <br /><text>within fill_input_buffer(); the latter is probably more efficient. If</text> <br /><text>fill_input_buffer() knows that no more data is available, it can set the</text> <br /><text>pointer/count to point to a dummy EOI marker and then return TRUE just as</text> <br /><text>though it had read more data in a non-suspending situation.</text> <br /><br /><text>The decompressor does not attempt to suspend within standard JPEG markers;</text> <br /><text>instead it will backtrack to the start of the marker and reprocess the whole</text> <br /><text>marker next time. Hence the input buffer must be large enough to hold the</text> <br /><text>longest standard marker in the file. Standard JPEG markers should normally</text> <br /><text>not exceed a few hundred bytes each (DHT tables are typically the longest).</text> <br /><text>We recommend at least a 2K buffer for performance reasons, which is much</text> <br /><text>larger than any correct marker is likely to be. For robustness against</text> <br /><text>damaged marker length counts, you may wish to insert a test in your</text> <br /><text>application for the case that the input buffer is completely full and yet</text> <br /><text>the decoder has suspended without consuming any data --- otherwise, if this</text> <br /><text>situation did occur, it would lead to an endless loop. (The library can't</text> <br /><text>provide this test since it has no idea whether "the buffer is full", or</text> <br /><text>even whether there is a fixed-size input buffer.)</text> <br /><br /><text>The input buffer would need to be 64K to allow for arbitrary COM or APPn</text> <br /><text>markers, but these are handled specially: they are either saved into allocated</text> <br /><text>memory, or skipped over by calling skip_input_data(). In the former case,</text> <br /><text>suspension is handled correctly, and in the latter case, the problem of</text> <br /><text>buffer overrun is placed on skip_input_data's shoulders, as explained above.</text> <br /><text>Note that if you provide your own marker handling routine for large markers,</text> <br /><text>you should consider how to deal with buffer overflow.</text> <br /><br /><text>Multiple-buffer management:</text> <br /><br /><text>In some applications it is desirable to store the compressed data in a linked</text> <br /><text>list of buffer areas, so as to avoid data copying. This can be handled by</text> <br /><text>having empty_output_buffer() or fill_input_buffer() set the pointer and count</text> <br /><text>to reference the next available buffer; FALSE is returned only if no more</text> <br /><text>buffers are available. Although seemingly straightforward, there is a</text> <br /><text>pitfall in this approach: the backtrack that occurs when FALSE is returned</text> <br /><text>could back up into an earlier buffer. For example, when fill_input_buffer()</text> <br /><text>is called, the current pointer and count indicate the backtrack restart point.</text> <br /><text>Since fill_input_buffer() will set the pointer and count to refer to a new</text> <br /><text>buffer, the restart position must be saved somewhere else. Suppose a second</text> <br /><text>call to fill_input_buffer() occurs in the same liebrary call, and no</text> <br /><text>additional input data is available, so fill_input_buffer must return FALSE.</text> <br /><text>If the JPEG library has not moved the pointer/count forward in the current</text> <br /><text>buffer, then *the correct restart point is the saved position in the prior</text> <br /><text>buffer*. Prior buffers may be discarded only after the library establishes</text> <br /><text>a restart point within a later buffer. Similar remarks apply for output into</text> <br /><text>a chain of buffers.</text> <br /><br /><text>The library will never attempt to backtrack over a skip_input_data() call,</text> <br /><text>so any skipped data can be permanently discarded. You still have to deal</text> <br /><text>with the case of skipping not-yet-received data, however.</text> <br /><br /><text>It's much simpler to use only a single buffer; when fill_input_buffer() is</text> <br /><text>called, move any unconsumed data (beyond the current pointer/count) down to</text> <br /><text>the beginning of this buffer and then load new data into the remaining buffer</text> <br /><text>space. This approach requires a little more data copying but is far easier</text> <br /><text>to get right.s</text> </descriptionarticle>
  </file>
</xml>