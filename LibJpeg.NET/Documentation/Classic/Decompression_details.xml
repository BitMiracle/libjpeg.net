<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Decompression details</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <p>
        <text>Here we revisit the JPEG decompression outline given in the </text> <link file="Outline_of_typical_usage.xml"><text>overview</text> </link><text>.</text> <br /><br /><b><text>1.</text> </b><text> Allocate and initialize a JPEG decompression object.</text> <br /><br /><text>This is just like initialization for compression, as discussed above, except that the object is a "class </text> <link file="../jpeg_decompress_struct.xml"><text>jpeg_decompress_struct</text> </link><text>". Error handling is exactly the same.</text> <br /><br /><text>Typical code:</text> <br /><br /><i><text>jpeg_error_mgr errorManager = new jpeg_error_mgr();</text> <br /><text>jpeg_decompress_struct cinfo = new jpeg_decompress_struct(errorManager);</text> <br /></i><br /><text>(Both here and in the IJG code, we usually use variable name "cinfo" for both compression and decompression objects.)</text> <br /><br /><b><text>2.</text> </b><text> Specify the source of the compressed data (e.g., a file).</text> <br /><br /><text>As previously mentioned, the JPEG library reads compressed data from a "data source" module. The library includes one data source module which knows how to read from a stdio stream. You can use your own source module if you want to do something else, as discussed later.</text> <br /><br /><text>If you use the standard source module, you must open the source stdio stream beforehand. Typical code for this step looks like:</text> <br /><br /><i><text>Stream input = ...; //initializing of stream for subsequent reading</text> <br /><text>cinfo.jpeg_stdio_dest(input);</text> <br /></i><br /><text>where the last line invokes the standard source module.</text> <br /><br /><text>You may not change the data source between calling </text> <link file="../jpeg_decompress_struct.jpeg_read_header.xml"><text>jpeg_read_header</text> </link><text>() and </text> <link file="../jpeg_decompress_struct.jpeg_finish_decompress.xml"><text>jpeg_finish_decompress</text> </link><text>(). If you wish to read a series of JPEG images from a single source file, you should repeat the jpeg_read_header() to jpeg_finish_decompress() sequence without reinitializing either the JPEG object or the data source module; this prevents buffered input data from being discarded.</text> <br /><br /><b><text>3.</text> </b><text> Call </text> <link file="../jpeg_decompress_struct.jpeg_read_header.xml"><text>jpeg_read_header</text> </link><text>() to obtain image info.</text> <br /><br /><text>Typical code for this step is just</text> <br /><br /><i><text>cinfo.jpeg_read_header(true);</text> </i><br /><br /><text>This will read the source datastream header markers, up to the beginning of the compressed data proper. On return, the image dimensions and other info have been stored in the JPEG object. The application may wish to consult this information before selecting decompression parameters.</text> <br /><br /><text>It is permissible to stop at this point if you just wanted to find out the image dimensions and other header info for a JPEG file. In that case, call </text> <link file="../jpeg_common_struct.jpeg_destroy.xml"><text>jpeg_destroy</text> </link><text>() when you are done with the JPEG object, or call </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>() to return it to an idle state before selecting a new data source and reading another header.</text> <br /><br /><b><text>4.</text> </b><text> Set parameters for decompression.</text> <br /><br /><link file="../jpeg_decompress_struct.jpeg_read_header.xml"><text>jpeg_read_header</text> </link><text>() sets appropriate default decompression parameters based on the properties of the image (in particular, its colorspace). However, you may well want to alter these defaults before beginning the decompression. For example, the default is to produce full color output from a color file. If you want colormapped output you must ask for it. Other options allow the returned image to be scaled and allow various speed/quality tradeoffs to be selected. "</text> <link file="Decompression_parameter_selection.xml"><text>Decompression parameter selection</text> </link><text>", below, gives details.</text> <br /><br /><text>If the defaults are appropriate, nothing need be done at this step.</text> <br /><br /><text>Note that all default values are set by each call to </text> <link file="../jpeg_decompress_struct.jpeg_read_header.xml"><text>jpeg_read_header</text> </link><text>(). If you reuse a decompression object, you cannot expect your parameter settings to be preserved across cycles, as you can for compression. You must set desired parameter values each time.</text> <br /><br /><b><text>5. </text> </b><link file="../jpeg_decompress_struct.jpeg_start_decompress.xml"><i><text>jpeg_start_decompress</text> </i></link><i><text>(...);</text> </i><br /><br /><text>Once the parameter values are satisfactory, call jpeg_start_decompress() to begin decompression. This will initialize internal state, allocate working memory, and prepare for returning data.</text> <br /><br /><text>Typical code is just</text> <br /><br /><i><text>cinfo.jpeg_start_decompress();</text> </i><br /><br /><text>If you have requested a multi-pass operating mode, such as 2-pass color quantization, jpeg_start_decompress() will do everything needed before data output can begin. In this case jpeg_start_decompress() may take quite a while to complete. With a single-scan (non progressive) JPEG file and default decompression parameters, this will not happen; jpeg_start_decompress() will</text> <br /><text>return quickly.</text> <br /><br /><text>After this call, the final output image dimensions, including any requested scaling, are available in the JPEG object; so is the selected colormap, if colormapped output has been requested. Useful fields include</text> </p>
      <p>
        <table>
          <tbody>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Output_width.xml">
                  <text>Output_width</text> </link>
              </td>
              <td>
                <text>Image width, as scaled</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Output_height.xml">
                  <text>Output_height</text> </link>
              </td>
              <td>
                <text>Image height, as scaled</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Out_color_components.xml">
                  <text>Out_color_components</text> </link>
              </td>
              <td>
                <text>Number of color components in out_color_space</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Output_components.xml">
                  <text>Output_components</text> </link>
              </td>
              <td>
                <text>Number of color components returned per pixel</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Colormap.xml">
                  <text>Colormap</text> </link>
              </td>
              <td>
                <text>The selected colormap, if any</text> </td>
            </tr>
            <tr>
              <td>
                <link file="../jpeg_decompress_struct.Actual_number_of_colors.xml">
                  <text>Actual_number_of_colors</text> </link>
              </td>
              <td>
                <text>Number of entries in colormap</text> </td>
            </tr>
          </tbody>
        </table>
        <br />
        <text>Output_components is 1 (a colormap index) when quantizing colors; otherwise it equals Out_color_components. It is the number of bytes that will be emitted per pixel in the output arrays.</text> <br /><br /><text>Typically you will need to allocate data buffers to hold the incoming image. You will need Output_width * Output_components bytes per scanline in your output buffer, and a total of Output_height scanlines will be returned.</text> <br /><br /><text>Note: if you are using the JPEG library's internal memory manager to allocate data buffers (as dJpeg does), then the manager's protocol requires that you request large buffers </text> <b><text>before</text> </b><text> calling </text> <link file="../jpeg_decompress_struct.jpeg_start_decompress.xml"><text>jpeg_start_decompress</text> </link><text>(). This is a little tricky since the Output_XXX fields are not normally valid then. You can make them valid by calling </text> <link file="../jpeg_decompress_struct.jpeg_calc_output_dimensions.xml"><text>jpeg_calc_output_dimensions</text> </link><text>() after setting the</text> <br /><text>relevant parameters (scaling, output color space and quantization flag)</text> <br /><br /><b><text>6. </text> </b><i><text>while (scan lines remain to be read)</text> <br /><text>        </text> <link file="../jpeg_decompress_struct.jpeg_read_scanlines.xml"><text>jpeg_read_scanlines</text> </link><text>(...);</text> </i><br /><br /><text>Now you can read the decompressed image data by calling jpeg_read_scanlines() one or more times. At each call, you pass in the maximum number of scanlines to be read (ie, the height of your working buffer); jpeg_read_scanlines() will return up to that many lines. The return value is the number of lines actually read. The format of the returned data is discussed under "</text> <link file="Data_formats.xml"><text>Data formats</text> </link><text>", above. Don't forget that grayscale and color JPEGs will return different data formats!</text> <br /><br /><text>Image data is returned in top-to-bottom scanline order. If you must write out the image in bottom-to-top order, you can use the JPEG library's virtual array mechanism to invert the data efficiently. Examples of this can be found in the sample application dJpeg.</text> <br /><br /><text>The library maintains a count of the number of scanlines returned so far in the </text> <link file="../jpeg_decompress_struct.Output_scanline.xml"><text>Output_scanline</text> </link><text> property of the JPEG object. Usually you can just use this variable as the loop counter, so that the loop test looks like "</text> <i><text>while (cinfo.Output_scanline &lt; cinfo.Output_height)</text> </i><text>". (Note that the test should NOT be against </text> <link file="../jpeg_compress_struct.Image_height.xml"><text>Image_height</text> </link><text>, unless you never use scaling. The Image_height property is the height of the original unscaled image.)</text> <br /><text>The return value always equals the change in the value of Output_scanline.</text> <br /><br /><text>If you don't use a suspending data source, it is safe to assume that </text> <link file="../jpeg_decompress_struct.jpeg_read_scanlines.xml"><text>jpeg_read_scanlines</text> </link><text>() reads at least one scanline per call, until the bottom of the image has been reached.</text> <br /><br /><text>If you use a buffer larger than one scanline, it is NOT safe to assume that jpeg_read_scanlines() fills it. (The current implementation returns only a few scanlines per call, no matter how large a buffer you pass.) So you must always provide a loop that calls jpeg_read_scanlines() repeatedly until the</text> <br /><text>whole image has been read.</text> <br /><br /><b><text>7. </text> </b><link file="../jpeg_decompress_struct.jpeg_finish_decompress.xml"><i><text>jpeg_finish_decompress</text> </i></link><i><text>(...);</text> </i><br /><br /><text>After all the image data has been read, call jpeg_finish_decompress() to complete the decompression cycle. This causes working memory associated with the JPEG object to be released.</text> <br /><br /><text>Typical code:</text> <br /><br /><i><text>cinfo.jpeg_finish_decompress();</text> </i><br /><br /><text>If using the standard source manager, don't forget to close the source stream if necessary.</text> <br /><br /><text>It is an error to call jpeg_finish_decompress() before reading the correct total number of scanlines. If you wish to abort decompression, call </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>() as discussed below.</text> <br /><br /><text>After completing a decompression cycle you may use it to decompress another image. In that case return to step 2 or 3 as appropriate. If you do not change the source manager, the next image will be read from the same source.</text> <br /><br /><b><text>8.</text> </b><text> Aborting.</text> <br /><br /><text>You can abort a decompression cycle by </text> <link file="../jpeg_decompress_struct.jpeg_abort_decompress.xml"><text>jpeg_abort_decompress</text> </link><text>() or </text> <link file="../jpeg_common_struct.jpeg_abort.xml"><text>jpeg_abort</text> </link><text>(). The previous discussion of aborting compression cycles applies here too.</text> </p>
    </descriptionarticle>
    <seealso>
      <ref caption="Outline of typical usage" file="Outline_of_typical_usage.xml" />
      <ref caption="Compression details" file="Compression_details.xml" />
    </seealso>
  </file>
</xml>