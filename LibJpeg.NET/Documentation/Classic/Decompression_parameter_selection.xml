<?xml version="1.0" encoding="UTF-8"?>
<xml>
  <file>
    <title>Decompression parameter selection</title>
    <breadcumbs>
      <link file="..\\Knowledge_base.xml">
        <text>Knowledge base</text>
      </link>
      <text> :: </text>
      <link file="..\Classic_LibJpeg.xml">
        <text>Classic LibJpeg</text>
      </link>
    </breadcumbs>
    <descriptionarticle only="true">
      <text>Decompression parameter selection is somewhat simpler than compression</text> <br /><text>parameter selection, since all of the JPEG internal parameters are</text> <br /><text>recorded in the source file and need not be supplied by the application.</text> <br /><text>(Unless you are working with abbreviated files, in which case see</text> <br /><text>"Abbreviated datastreams", below.) Decompression parameters control</text> <br /><text>the postprocessing done on the image to deliver it in a format suitable</text> <br /><text>for the application's use. Many of the parameters control speed/quality</text> <br /><text>tradeoffs, in which faster decompression may be obtained at the price of</text> <br /><text>a poorer-quality image. The defaults select the highest quality (slowest)</text> <br /><text>processing.</text> <br /><br /><text>The following fields in the JPEG object are set by jpeg_read_header() and</text> <br /><text>may be useful to the application in choosing decompression parameters:</text> <br /><br /><text>JDIMENSION image_width Width and height of image</text> <br /><text>JDIMENSION image_height</text> <br /><text>int num_components Number of color components</text> <br /><text>J_COLOR_SPACE jpeg_color_space Colorspace of image</text> <br /><text>boolean saw_JFIF_marker TRUE if a JFIF APP0 marker was seen</text> <br /><text>UINT8 JFIF_major_version Version information from JFIF marker</text> <br /><text>UINT8 JFIF_minor_version</text> <br /><text>UINT8 density_unit Resolution data from JFIF marker</text> <br /><text>UINT16 X_density</text> <br /><text>UINT16 Y_density</text> <br /><text>boolean saw_Adobe_marker TRUE if an Adobe APP14 marker was seen</text> <br /><text>UINT8 Adobe_transform Color transform code from Adobe marker</text> <br /><br /><text>The JPEG color space, unfortunately, is something of a guess since the JPEG</text> <br /><text>standard proper does not provide a way to record it. In practice most files</text> <br /><text>adhere to the JFIF or Adobe conventions, and the decoder will recognize these</text> <br /><text>correctly. See "Special color spaces", below, for more info.</text> <br /><br /><br /><text>The decompression parameters that determine the basic properties of the</text> <br /><text>returned image are:</text> <br /><br /><text>J_COLOR_SPACE out_color_space</text> <br /><text>Output color space. jpeg_read_header() sets an appropriate default</text> <br /><text>based on jpeg_color_space; typically it will be RGB or grayscale.</text> <br /><text>The application can change this field to request output in a different</text> <br /><text>colorspace. For example, set it to JCS_GRAYSCALE to get grayscale</text> <br /><text>output from a color file. (This is useful for previewing: grayscale</text> <br /><text>output is faster than full color since the color components need not</text> <br /><text>be processed.) Note that not all possible color space transforms are</text> <br /><text>currently implemented; you may need to extend jdcolor.c if you want an</text> <br /><text>unusual conversion.</text> <br /><br /><text>unsigned int scale_num, scale_denom</text> <br /><text>Scale the image by the fraction scale_num/scale_denom. Default is</text> <br /><text>1/1, or no scaling. Currently, the only supported scaling ratios</text> <br /><text>are 1/1, 1/2, 1/4, and 1/8. (The library design allows for arbitrary</text> <br /><text>scaling ratios but this is not likely to be implemented any time soon.)</text> <br /><text>Smaller scaling ratios permit significantly faster decoding since</text> <br /><text>fewer pixels need be processed and a simpler IDCT method can be used.</text> <br /><br /><text>boolean quantize_colors</text> <br /><text>If set TRUE, colormapped output will be delivered. Default is FALSE,</text> <br /><text>meaning that full-color output will be delivered.</text> <br /><br /><text>The next three parameters are relevant only if quantize_colors is TRUE.</text> <br /><br /><text>int desired_number_of_colors</text> <br /><text>Maximum number of colors to use in generating a library-supplied color</text> <br /><text>map (the actual number of colors is returned in a different field).</text> <br /><text>Default 256. Ignored when the application supplies its own color map.</text> <br /><br /><text>boolean two_pass_quantize</text> <br /><text>If TRUE, an extra pass over the image is made to select a custom color</text> <br /><text>map for the image. This usually looks a lot better than the one-size-</text> <br /><text>fits-all colormap that is used otherwise. Default is TRUE. Ignored</text> <br /><text>when the application supplies its own color map.</text> <br /><br /><text>J_DITHER_MODE dither_mode</text> <br /><text>Selects color dithering method. Supported values are:</text> <br /><text>JDITHER_NONE no dithering: fast, very low quality</text> <br /><text>JDITHER_ORDERED ordered dither: moderate speed and quality</text> <br /><text>JDITHER_FS Floyd-Steinberg dither: slow, high quality</text> <br /><text>Default is JDITHER_FS. (At present, ordered dither is implemented</text> <br /><text>only in the single-pass, standard-colormap case. If you ask for</text> <br /><text>ordered dither when two_pass_quantize is TRUE or when you supply</text> <br /><text>an external color map, you'll get F-S dithering.)</text> <br /><br /><text>When quantize_colors is TRUE, the target color map is described by the next</text> <br /><text>two fields. colormap is set to NULL by jpeg_read_header(). The application</text> <br /><text>can supply a color map by setting colormap non-NULL and setting</text> <br /><text>actual_number_of_colors to the map size. Otherwise, jpeg_start_decompress()</text> <br /><text>selects a suitable color map and sets these two fields itself.</text> <br /><text>[Implementation restriction: at present, an externally supplied colormap is</text> <br /><text>only accepted for 3-component output color spaces.]</text> <br /><br /><text>JSAMPARRAY colormap</text> <br /><text>The color map, represented as a 2-D pixel array of out_color_components</text> <br /><text>rows and actual_number_of_colors columns. Ignored if not quantizing.</text> <br /><text>CAUTION: if the JPEG library creates its own colormap, the storage</text> <br /><text>pointed to by this field is released by jpeg_finish_decompress().</text> <br /><text>Copy the colormap somewhere else first, if you want to save it.</text> <br /><br /><text>int actual_number_of_colors</text> <br /><text>The number of colors in the color map.</text> <br /><br /><text>Additional decompression parameters that the application may set include:</text> <br /><br /><text>J_DCT_METHOD dct_method</text> <br /><text>Selects the algorithm used for the DCT step. Choices are the same</text> <br /><text>as described above for compression.</text> <br /><br /><text>boolean do_fancy_upsampling</text> <br /><text>If TRUE, do careful upsampling of chroma components. If FALSE,</text> <br /><text>a faster but sloppier method is used. Default is TRUE. The visual</text> <br /><text>impact of the sloppier method is often very small.</text> <br /><br /><text>boolean do_block_smoothing</text> <br /><text>If TRUE, interblock smoothing is applied in early stages of decoding</text> <br /><text>progressive JPEG files; if FALSE, not. Default is TRUE. Early</text> <br /><text>progression stages look "fuzzy" with smoothing, "blocky" without.</text> <br /><text>In any case, block smoothing ceases to be applied after the first few</text> <br /><text>AC coefficients are known to full accuracy, so it is relevant only</text> <br /><text>when using buffered-image mode for progressive images.</text> <br /><br /><text>boolean enable_1pass_quant</text> <br /><text>boolean enable_external_quant</text> <br /><text>boolean enable_2pass_quant</text> <br /><text>These are significant only in buffered-image mode, which is</text> <br /><text>described in its own section below.</text> <br /><br /><br /><text>The output image dimensions are given by the following fields. These are</text> <br /><text>computed from the source image dimensions and the decompression parameters</text> <br /><text>by jpeg_start_decompress(). You can also call jpeg_calc_output_dimensions()</text> <br /><text>to obtain the values that will result from the current parameter settings.</text> <br /><text>This can be useful if you are trying to pick a scaling ratio that will get</text> <br /><text>close to a desired target size. It's also important if you are using the</text> <br /><text>JPEG library's memory manager to allocate output buffer space, because you</text> <br /><text>are supposed to request such buffers *before* jpeg_start_decompress().</text> <br /><br /><text>JDIMENSION output_width Actual dimensions of output image.</text> <br /><text>JDIMENSION output_height</text> <br /><text>int out_color_components Number of color components in out_color_space.</text> <br /><text>int output_components Number of color components returned.</text> <br /><text>int rec_outbuf_height Recommended height of scanline buffer.</text> <br /><br /><text>When quantizing colors, output_components is 1, indicating a single color map</text> <br /><text>index per pixel. Otherwise it equals out_color_components. The output arrays</text> <br /><text>are required to be output_width * output_components JSAMPLEs wide.</text> <br /><br /><text>rec_outbuf_height is the recommended minimum height (in scanlines) of the</text> <br /><text>buffer passed to jpeg_read_scanlines(). If the buffer is smaller, the</text> <br /><text>library will still work, but time will be wasted due to unnecessary data</text> <br /><text>copying. In high-quality modes, rec_outbuf_height is always 1, but some</text> <br /><text>faster, lower-quality modes set it to larger values (typically 2 to 4).</text> <br /><text>If you are going to ask for a high-speed processing mode, you may as well</text> <br /><text>go to the trouble of honoring rec_outbuf_height so as to avoid data copying.</text> <br /><text>(An output buffer larger than rec_outbuf_height lines is OK, but won't</text> <br /><text>provide any material speed improvement over that height.)</text> <br /></descriptionarticle>
  </file>
</xml>